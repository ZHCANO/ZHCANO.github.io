<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>集群聊天服务器实战</title>
    <link href="/%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h2><p>本项目是一个仿QQ聊天的即时通讯系统，主要业务有登录、注册、注销、添加好友、创建或加入群组、一对一聊天以及群组聊天等。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>Ubuntu 18.04.6 LTS</li><li>安装Json开发库</li><li>安装boost+muduo网络库开发环境，参考<a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980">C++ muduo网络库知识分享01 - Linux平台下muduo网络库源码编译安装-CSDN博客</a></li><li>安装redis环境</li><li>安装mysql数据库环境</li><li>安装nginx</li><li>安装CMake环境</li></ul><h2 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h2><ul><li>Json序列化和反序列化</li><li>基于muduo网络库的服务端程序开发</li><li>Nginx的TCP负载均衡器配置</li><li>基于发布-订阅的Redis消息队列编程实战</li><li>MySQL数据库编程</li><li>CMake构建编译环境</li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Json数据序列化方法"><a href="#Json数据序列化方法" class="headerlink" title="Json数据序列化方法"></a>Json数据序列化方法</h3><p>Json是一种<strong>完全独立于编程语言</strong>的文本格式数据存储方式（两个主机使用的编程语言可能不同），常用的数据传输序列化格式有XML，Json，ProtoBuf（公司级别项目用ProtoBuf，压缩编码传输，是1&#x2F;10Json，1&#x2F;20XML）。</p><p>(1) json第三方库的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;json.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> json = nlohmann::json<br></code></pre></td></tr></table></figure><p>(2) json的数据序列化方式（把数据处理成Json字符串）</p><p>普通数据序列化（可以添加数组&#x2F;二维）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>    json js;<br>    js[<span class="hljs-string">&quot;msg_type&quot;</span>] = <span class="hljs-number">2</span>;<br>    js[<span class="hljs-string">&quot;from&quot;</span>] = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>    js[<span class="hljs-string">&quot;to&quot;</span>] = <span class="hljs-string">&quot;lisi&quot;</span>;<br>    js[<span class="hljs-string">&quot;msg&quot;</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string sendBuf = js.<span class="hljs-built_in">dump</span>(); <span class="hljs-comment">// 将 json 转换为字符串</span><br>    <span class="hljs-keyword">return</span> sendBuf;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 测试结果：&#123;&quot;from&quot;:&quot;zhangsan&quot;,&quot;msg&quot;:&quot;hello&quot;,&quot;msg_type&quot;:2,&quot;to&quot;:&quot;lisi&quot;&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>容器序列化（直接将容器放进json）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>&#123;<br>    json js;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    js[<span class="hljs-string">&quot;list&quot;</span>] = vec;<br>    unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map;<br>    map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;黄山&quot;</span>&#125;);<br>    map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;华山&quot;</span>&#125;);<br>    map.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;高山&quot;</span>&#125;);<br>    js[<span class="hljs-string">&quot;path&quot;</span>] = map;<br>    string sendBuf = js.<span class="hljs-built_in">dump</span>(); <span class="hljs-comment">// 将 json 转换为字符串</span><br>    <span class="hljs-keyword">return</span> sendBuf;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 测试结果：&#123;&quot;list&quot;:[1,2,3],&quot;path&quot;:[[3,&quot;高山&quot;],[1,&quot;黄山&quot;],[2,&quot;华山&quot;]]&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>(3) json数据反序列化（把json字符串反序列化出对象&#x2F;容器）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string jsonstr = <span class="hljs-built_in">func2</span>();<br>json js = json::<span class="hljs-built_in">parse</span>(jsonstr); <span class="hljs-comment">// 反序列化</span><br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map = js[<span class="hljs-string">&quot;path&quot;</span>];<br>cout &lt;&lt; map[<span class="hljs-number">1</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="muduo网络库"><a href="#muduo网络库" class="headerlink" title="muduo网络库"></a>muduo网络库</h3><p>muduo网络库给用户提供了两个主要的类，用于编写服务器程序的TcpServer和用于编写客户端程序TcpClient。muduo网络库的优点是能够把网络I&#x2F;O（用户的连接和断开）和业务代码（用户的可读写事件）区分开。</p><p><strong>基于muduo网络库开发服务器程序的步骤：</strong></p><ol><li>组合TcpServer对象</li><li>创建EventLoop事件循环对象的指针</li><li>明确TcpServer构造函数需要什么参数，输出ChatServer的构造函数</li><li>在当前服务器类的构造函数中，注册处理连接的回调函数和处理读写事件的回调函数</li><li>设置合适的服务端线程数量，muduo库会自己分配I&#x2F;O线程和worker线程</li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/net/TcpServer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/net/EventLoop.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> muduo;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> muduo::net;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> placeholders;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatServer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ChatServer</span>(EventLoop* loop, <span class="hljs-comment">// 事件循环</span><br>            <span class="hljs-type">const</span> InetAddress&amp; listenAddr, <span class="hljs-comment">// IP+Port</span><br>            <span class="hljs-type">const</span> string&amp; nameArg) <span class="hljs-comment">// 服务器的名字</span><br>        : _server(loop, listenAddr,nameArg), _loop(loop)<br>    &#123;<br>        <span class="hljs-comment">// 给服务器注册用户连接的创建和断开的回调</span><br>        _server.<span class="hljs-built_in">setConnectionCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;ChatServer::onConnection, <span class="hljs-keyword">this</span>, _1));<br>        <span class="hljs-comment">// 给服务器注册用户读写事件回调</span><br>        _server.<span class="hljs-built_in">setMessageCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;ChatServer::onMessage, <span class="hljs-keyword">this</span>, _1, _2, _3));<br>        <span class="hljs-comment">// 设置服务器端的线程数量 1 I/O + 3 worker</span><br>        _server.<span class="hljs-built_in">setThreadNum</span>(<span class="hljs-number">4</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 开启事件循环</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        _server.<span class="hljs-built_in">start</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 专门处理用户的连接创建和断开 epoll listenfd accept</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr&amp; conn)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(conn-&gt;<span class="hljs-built_in">connected</span>()) &#123;<br>            cout &lt;&lt; conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>() &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">localAddress</span>().<span class="hljs-built_in">toIpPort</span>() &lt;&lt; <span class="hljs-string">&quot;state::online&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; conn-&gt;<span class="hljs-built_in">peerAddress</span>().<span class="hljs-built_in">toIpPort</span>() &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; conn-&gt;<span class="hljs-built_in">localAddress</span>().<span class="hljs-built_in">toIpPort</span>() &lt;&lt; <span class="hljs-string">&quot;state::offline&quot;</span> &lt;&lt; endl;<br>            conn-&gt;<span class="hljs-built_in">shutdown</span>();<br>            <span class="hljs-comment">// _loop-&gt;quit();</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 专门处理用户的读写事件</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr&amp; conn, Buffer* buffer, Timestamp time)</span> </span>&#123; <span class="hljs-comment">// 连接、缓冲区、时间戳</span><br>        string buf = buffer-&gt;<span class="hljs-built_in">retrieveAllAsString</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;recv data:&quot;</span> &lt;&lt; buf &lt;&lt; <span class="hljs-string">&quot;time&quot;</span> &lt;&lt; time.<span class="hljs-built_in">toString</span>() &lt;&lt; endl;<br>        conn-&gt;<span class="hljs-built_in">send</span>(buf);<br>    &#125;<br>    TcpServer _server;<br>    EventLoop* _loop;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    EventLoop loop;<br>    <span class="hljs-function">InetAddress <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6000</span>)</span></span>;<br>    <span class="hljs-function">ChatServer <span class="hljs-title">server</span><span class="hljs-params">(&amp;loop, addr, <span class="hljs-string">&quot;ChatServer&quot;</span>)</span></span>;<br><br>    server.<span class="hljs-built_in">start</span>(); <span class="hljs-comment">// listenfd epoll_ctl=&gt;epoll</span><br>    loop.<span class="hljs-built_in">loop</span>(); <span class="hljs-comment">// epoll_wait 以阻塞方式等待新用户连接、已连接用户的读写事件</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ muduo_server.cpp -o server -lmuduo_net -lmuduo_base -lpthread<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>TIP</p><p>-I头文件搜索路径 -L库文件搜索路径 -l库名 </p><p>&#x2F;usr&#x2F;include &#x2F;usr&#x2F;local&#x2F;include 下的文件会被程序默认包含，不需要特意写出</p>          </div><p>运行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">terminal1:<br>./server<br>terminal2:<br>telnet 127.0.0.1 6000<br></code></pre></td></tr></table></figure><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20231229194222707.png"></p><blockquote><p>按ctrl+]键结束，输入quit退出</p></blockquote><h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><p>CMake是一种跨平台的编译工具，可以通过CMakeLists.txt文件定制整个编译流程，再生成make所需要的makefile文件，最后使用make命令编译源码生成可执行程序或共享库。</p><h4 id="CMake的安装"><a href="#CMake的安装" class="headerlink" title="CMake的安装"></a>CMake的安装</h4><p>ubuntu CMake的安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt install cmake<br>$ cmake -version<br></code></pre></td></tr></table></figure><p>VS Code CMake的安装：</p><p>(1) VS Code 扩展-&gt;搜索CMake-&gt;点击CMake和CMake Tools安装（注意：远程主机中也要安装）</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20231229202506032.png"></p><p>(2) 点击CMake Tools右侧齿轮-&gt;Extension Setting（扩展设置）-&gt;远程-&gt;Cmake:Build Environment-&gt;添加项</p><p>项：<code>cmake.cmakePath</code> 值：<code>/usr/bin/cmake</code></p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20231229203455632.png"></p><h4 id="CMake的使用"><a href="#CMake的使用" class="headerlink" title="CMake的使用"></a>CMake的使用</h4><p>标准的文件组织：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">bin:</span> 可执行文件<br><span class="hljs-symbol">lib:</span> 库文件<br><span class="hljs-symbol">include:</span> 头文件<br><span class="hljs-symbol">src:</span> 源文件<br><span class="hljs-symbol">build:</span> 编译过程中产生的临时文件<br><span class="hljs-symbol">example:</span> 测试文件<br><span class="hljs-symbol">thridparty:</span> 依赖的第三方库文件<br>CMakeList.txt<br><span class="hljs-symbol">autobulid.sh:</span> 一键编译<br></code></pre></td></tr></table></figure><p>创建bin和build目录，并新建CMakeLists.txt文件，结构如下：</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20231229205244343.png"></p><p>编写CMakeLists.txt文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>) <span class="hljs-comment"># 要求cmake最低的版本号</span><br><span class="hljs-keyword">project</span>(main) <span class="hljs-comment"># 定义当前工程名字</span><br><br><span class="hljs-comment"># 配置编译选项</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-variable">$&#123;CMAKE_CXX_FLAGS&#125;</span> -g)<br><br><span class="hljs-comment"># 设置可执行文件最终存储的路径</span><br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><br><span class="hljs-comment"># 设置需要编译的源文件列表</span><br><span class="hljs-keyword">set</span>(SRC_LIST ./muduo_server.cpp)<br><br><span class="hljs-comment"># 表示生成可执行文件server，由SRC_LIST变量所定义的源文件编译而来</span><br><span class="hljs-keyword">add_executable</span>(server <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br><br><span class="hljs-comment"># 表示server这个目标程序，需要链接 muduo_net muduo_base pthread 这三个库文件</span><br><span class="hljs-keyword">target_link_libraries</span>(server muduo_net muduo_base pthread)<br></code></pre></td></tr></table></figure><p>执行命令<code>cmake PATH</code>生成Makefile：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> build<br>cmake ..<br></code></pre></td></tr></table></figure><p>使用<code>make</code>命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>在bin目录下成功生成了可执行文件。</p><h4 id="在VS-Code下配置CMake"><a href="#在VS-Code下配置CMake" class="headerlink" title="在VS Code下配置CMake"></a>在VS Code下配置CMake</h4><p>(1) 在chat的同级目录下新建CMakeLists.txt文件，将前面编写的CMakeLists.txt文件中的前两行<strong>剪切</strong>到新文件中，同时添加指定工程的子目录。</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20231229211801320.png"></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>) <span class="hljs-comment"># 要求cmake最低的版本号</span><br><span class="hljs-keyword">project</span>(main) <span class="hljs-comment"># 定义当前工程名字</span><br><br><span class="hljs-comment"># 指定工程的子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(chat)<br></code></pre></td></tr></table></figure><p>(2) 点击CMake-&gt;生成所有项目</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20231229211843212.png"></p><p>(3) 执行完成后，在当前目录下会生成bin和build目录。</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20231229211952719.png"></p><h2 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h2><p><strong>User表</strong></p><table><thead><tr><th align="center">字段名称</th><th align="center">字段类型</th><th align="center">字段说明</th><th align="center">约束</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">INT</td><td align="center">用户id</td><td align="center">PRIMARY KEY、AUTO_INCREMENT、NOT NULL</td></tr><tr><td align="center">name</td><td align="center">VARCHAR(50)</td><td align="center">用户名</td><td align="center">NOT NULL, UNIQUE</td></tr><tr><td align="center">password</td><td align="center">VARCHAR(50)</td><td align="center">密码</td><td align="center">NOT NULL</td></tr><tr><td align="center">state</td><td align="center">ENUM(‘online’, ‘offline’)</td><td align="center">当前登录状态</td><td align="center">DEFAULT ‘offline’</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>`(id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">PRIMARY</span> KEY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>,<br>    `password` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    `state` ENUM(<span class="hljs-string">&#x27;online&#x27;</span>,<span class="hljs-string">&#x27;offline&#x27;</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;offline&#x27;</span>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p><strong>Friend 表</strong></p><table><thead><tr><th align="center">字段名称</th><th align="center">字段类型</th><th align="center">字段说明</th><th align="center">约束</th></tr></thead><tbody><tr><td align="center">userid</td><td align="center">INT</td><td align="center">用户id</td><td align="center">NOT NULL、联合主键</td></tr><tr><td align="center">friendid</td><td align="center">INT</td><td align="center">好友id</td><td align="center">NOT NULL、联合主键</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> friend (<br>    userid <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    friendid <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (userid, friendid)<br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p><strong>AllGroup表</strong></p><table><thead><tr><th align="center">字段名称</th><th align="center">字段类型</th><th align="center">字段说明</th><th align="center">约束</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">INT</td><td align="center">组id</td><td align="center">PRIMARY KEY、AUTO_INCREMENT</td></tr><tr><td align="center">groupname</td><td align="center">VARCHAR(50)</td><td align="center">组名称</td><td align="center">NOT NULL, UNIQUE</td></tr><tr><td align="center">groupdesc</td><td align="center">VARCHAR(50)</td><td align="center">组功能描述</td><td align="center">DEFAULT ‘ ‘</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> allgroup (<br>    id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">PRIMARY</span> KEY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    groupname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>,<br>    groupdesc <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27; &#x27;</span><br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p><strong>GroupUser表</strong></p><table><thead><tr><th align="center">字段名称</th><th align="center">字段类型</th><th align="center">字段说明</th><th align="center">约束</th></tr></thead><tbody><tr><td align="center">groupid</td><td align="center">INT</td><td align="center">组id</td><td align="center">NOT NULL、联合主键</td></tr><tr><td align="center">userid</td><td align="center">INT</td><td align="center">组员id</td><td align="center">NOT NULL、联合主键</td></tr><tr><td align="center">grouprole</td><td align="center">ENUM(‘creator’, ‘normal’)</td><td align="center">组内角色</td><td align="center">DEFAULT ‘ normal’</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> groupuser (<br>    groupid <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    userid <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    grouprole ENUM(<span class="hljs-string">&#x27;creator&#x27;</span>, <span class="hljs-string">&#x27;normal&#x27;</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;normal&#x27;</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (groupid, userid)<br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p><strong>OfflineMessage表</strong></p><table><thead><tr><th align="center">字段名称</th><th align="center">字段类型</th><th align="center">字段说明</th><th align="center">约束</th></tr></thead><tbody><tr><td align="center">userid</td><td align="center">INT</td><td align="center">用户id</td><td align="center">NOT NULL</td></tr><tr><td align="center">message</td><td align="center">VARCHAR(500)</td><td align="center">离线消息（存储Json字符串）</td><td align="center">NOT NULL</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> offlinemessage (<br>    userid <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    message <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">500</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><p>基本业务有登录、注册和注销，在用户登录后，界面显示好友列表、群组列表和离线消息等个人信息，可以选择添加好友、创建或加入群组、一对一聊天以及群组聊天等服务，下面是业务流程的详细设计。</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240217155755520.png"></p><h2 id="数据通信方式"><a href="#数据通信方式" class="headerlink" title="数据通信方式"></a>数据通信方式</h2><p>客户端和服务端的通信使用JSON序列化和反序列化作为通信协议，对于不同的数据设计了不同的格式，具体设计如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1.登录</span><br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = LOGIN_MSG;<br>json[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment">// 用户id</span><br>json[<span class="hljs-string">&quot;password&quot;</span>]<span class="hljs-comment">// 密码</span><br><br><span class="hljs-comment">// 2.登录响应</span><br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = LOGIN_MSG_ACK;<br>json[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment">// 用户id</span><br>json[<span class="hljs-string">&quot;name&quot;</span>]<span class="hljs-comment">// 用户名</span><br>json[<span class="hljs-string">&quot;offlinemsg&quot;</span>]<span class="hljs-comment">// 离线消息</span><br>json[<span class="hljs-string">&quot;friends&quot;</span>]<span class="hljs-comment">// 好友信息&#123;id, name, state&#125;</span><br>json[<span class="hljs-string">&quot;groups&quot;</span>]<span class="hljs-comment">// 群组信息&#123;id, groupname, groupdesc，users&#123;id, name，state, role&#125;&#125;</span><br>json[<span class="hljs-string">&quot;errno&quot;</span>]<span class="hljs-comment">// 错误号，0：登录成功，1：账号或密码错误，2：该用户已经登录，不允许重复登录</span><br>json[<span class="hljs-string">&quot;errmsg&quot;</span>]<span class="hljs-comment">// 错误信息</span><br><br><span class="hljs-comment">// 3.注册</span><br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = REG_MSG;<br>json[<span class="hljs-string">&quot;name&quot;</span>]<span class="hljs-comment">//用户名</span><br>json[<span class="hljs-string">&quot;password&quot;</span>]<span class="hljs-comment">//用户密码</span><br><br><span class="hljs-comment">// 4.注册响应</span><br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = REG_MSG_ACK;<br>json[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment">// 返回用户注册的id</span><br>json[<span class="hljs-string">&quot;errno&quot;</span>]<span class="hljs-comment">// 错误号，0：成功，1：失败</span><br><br><span class="hljs-comment">// 5.添加好友</span><br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = ADD_FRIEND_MSG;<br>json[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment">// 当前用户id</span><br>json[<span class="hljs-string">&quot;friendid&quot;</span>]<span class="hljs-comment">// 好友id</span><br><br><span class="hljs-comment">// 6.一对一聊天</span><br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = ONE_CHAT_MSG;<br>json[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment">// 用户id</span><br>json[<span class="hljs-string">&quot;name&quot;</span>]<span class="hljs-comment">// 用户姓名</span><br>json[<span class="hljs-string">&quot;toid&quot;</span>]    <span class="hljs-comment">// 接受者id</span><br>json[<span class="hljs-string">&quot;msg&quot;</span>]<span class="hljs-comment">// 消息内容</span><br>json[<span class="hljs-string">&quot;time&quot;</span>]<span class="hljs-comment">// 发送时间</span><br><br><span class="hljs-comment">// 7.创建群</span><br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = CREATE_GROUP_MSG;<br>json[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment">// 群创建者id</span><br>json[<span class="hljs-string">&quot;groupname&quot;</span>]<span class="hljs-comment">// 群名</span><br>json[<span class="hljs-string">&quot;groupdesc&quot;</span>]<span class="hljs-comment">// 群描述</span><br><br><span class="hljs-comment">// 8.加入群</span><br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = ADD_GROUP_MSG;<br>json[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment">//用户id</span><br>json[<span class="hljs-string">&quot;groupid&quot;</span>]<span class="hljs-comment">//群id</span><br><br><span class="hljs-number">9.</span>群聊<br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = GROUP_CHAT_MSG;<br>json[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment">// id</span><br>json[<span class="hljs-string">&quot;name&quot;</span>]<span class="hljs-comment">// name</span><br>json[<span class="hljs-string">&quot;groupid&quot;</span>]<span class="hljs-comment">// groupid</span><br>json[<span class="hljs-string">&quot;msg&quot;</span>]<span class="hljs-comment">// 消息内容</span><br>json[<span class="hljs-string">&quot;time&quot;</span>]<span class="hljs-comment">// 发送时间</span><br><br><span class="hljs-number">10.</span>注销<br>json[<span class="hljs-string">&quot;msgid&quot;</span>] = LOGINOUT_MSG;<br>json[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment">// id</span><br></code></pre></td></tr></table></figure><h2 id="网络和业务模块"><a href="#网络和业务模块" class="headerlink" title="网络和业务模块"></a>网络和业务模块</h2><h3 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h3><p>网络模块使用的是muduo提供的接口，muduo网络库的优点是能够把网络I&#x2F;O（用户的连接和断开）和业务代码（用户的可读写事件）区分开，这样就可以专注于编写业务代码，而不需要考虑网络I&#x2F;O的细节。</p><p>muduo网络库设计的核心思想是one loop per thread，有一个main reactor监听accept连接，然后把连接分发到某个sub reactor上（轮询的方式选择），sub reactor负责连接事件的处理。如果有过多耗费CPU I&#x2F;O的计算任务，可以提交到线程池中处理。</p><p>muduo中提供了两个非常重要的回调函数：连接回调和读写回调</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 注册连接回调</span><br>_server.<span class="hljs-built_in">setConnectionCallback</span>(<span class="hljs-built_in">bind</span>(&amp;ChatServer::onConnection, <span class="hljs-keyword">this</span>, _1));<br><span class="hljs-comment">// 注册读写回调</span><br>_server.<span class="hljs-built_in">setMessageCallback</span>(<span class="hljs-built_in">bind</span>(&amp;ChatServer::onMessage, <span class="hljs-keyword">this</span>, _1, _2, _3));<br></code></pre></td></tr></table></figure><p>在_server上注册连接回调和读写回调函数，当网络IO事件或读写事件到达时，就会调用相应的回调函数进行处理。</p><h3 id="业务模块"><a href="#业务模块" class="headerlink" title="业务模块"></a>业务模块</h3><p>业务模块的设计采用线程安全的懒汉式单例模式，即一个类不管创建多少对象，永远只能得到该类型的一个对象实例。</p><p><strong>主要业务有：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 处理登录业务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">login</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr&amp; conn, json &amp;js, Timestamp time)</span></span>;<br><span class="hljs-comment">// 处理注册业务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reg</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr&amp; conn, json &amp;js, Timestamp time)</span></span>;<br><span class="hljs-comment">// 一对一聊天业务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oneChat</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;<br><span class="hljs-comment">// 添加好友业务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addFriend</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;<br><span class="hljs-comment">// 创建群组业务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createGroup</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;<br><span class="hljs-comment">// 加入群组业务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addGroup</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;<br><span class="hljs-comment">// 群组聊天业务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">groupChat</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;<br><span class="hljs-comment">// 处理注销业务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loginout</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn, json &amp;js, Timestamp time)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>业务逻辑的处理主要可以分为两类：</strong></p><ol><li>登录&#x2F;注册&#x2F;添加好友&#x2F;创建群组&#x2F;注销：服务端将接收到的Json字符串反序列化，得到所需关键字对应的key值，按具体的业务逻辑进行处理后，再修改数据库中对应的用户信息。</li><li>聊天业务：服务端检查私聊或群聊的对象是否在线，如果在线，就转发请求，如果不在线，就将内容存储到对应用户的离线消息中。</li></ol><h3 id="网络模块与业务模块解耦"><a href="#网络模块与业务模块解耦" class="headerlink" title="网络模块与业务模块解耦"></a>网络模块与业务模块解耦</h3><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240102200736807.png"></p><p>如果在网络模块的读写回调中直接调用业务模块的方法，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (消息ID1) <br><span class="hljs-keyword">else</span> 注册<br></code></pre></td></tr></table></figure><p>那么当出现新的业务需求（如添加登录功能）时，网络模块也需要修改代码</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">if</span> (消息ID1) <br><span class="hljs-keyword">else</span> 注册<br><span class="hljs-keyword">if</span> (消息ID2)<br><span class="hljs-keyword">else</span> 登录<br></code></pre></td></tr></table></figure><p><strong>网络模块与业务模块解耦的本质操作是使用unordered_map将消息id映射到业务处理方法。</strong>网络模块<code>chatserver</code>可以通过<code>map</code>直接获取对应的业务处理方法，这样业务的增加或删除只在业务模块<code>chatservice</code>中进行，解耦了网络操作和业务操作。</p><h2 id="数据模块"><a href="#数据模块" class="headerlink" title="数据模块"></a>数据模块</h2><p>数据库编程相关API的使用已经在<a href="http://zhcan.online/%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">手写数据库连接池</a>中介绍过，这里不再赘述。</p><h3 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h3><p><strong>ORM（对象-关系映射）可以将数据库表的结构和数据映射到对象模型中，封装了数据库操作，使上层开发可以直接使用面向对象的方式来操作数据库，不需要直接编写SQL语句。</strong></p><p><strong>ORM把数据库映射成对象：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl">数据库的表（<span class="hljs-function"><span class="hljs-title">table</span>） --&gt;</span> 类（class）<br>记录（<span class="hljs-function"><span class="hljs-title">record</span>，行数据）--&gt;</span> 对象（object）<br>字段（<span class="hljs-function"><span class="hljs-title">field</span>）--&gt;</span> 对象的属性（attribute）<br></code></pre></td></tr></table></figure><p><strong>ORM的优点：</strong></p><ul><li>数据模型都在一个地方定义，更容易更新维护和重用代码，提高开发效率。</li><li>基于ORM的业务代码比较简单，代码量少，语义性好，容易理解。</li><li>代码结构更清晰，并且不必编写性能不佳的 SQL。</li></ul><p><strong>ORM的缺点：</strong></p><ul><li>对于复杂的查询，ORM可能会无法表达，或者是性能不如原生的 SQL。</li></ul><h3 id="数据模块设计"><a href="#数据模块设计" class="headerlink" title="数据模块设计"></a>数据模块设计</h3><p>User类、Group类负责暂存从数据库查询到的内容，或者是服务器解析的Json字符串的信息；Model类调用db.h中的函数，负责对数据库进行增删改查；db.h封装了MySQL C的API。</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1.jpg"></p><h2 id="客户端程序实现"><a href="#客户端程序实现" class="headerlink" title="客户端程序实现"></a>客户端程序实现</h2><p>客户端主要有一个发送线程和一个接收线程，发送线程解析用户的命令，调用相应的回调函数，将封装好的Json字符串发送给服务端；接收线程负责接收服务的转发的数据，对接收到的数据进行反序列化，显示聊天的消息内容。客户端的详细设计如下：</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240220160811552.png"></p><h2 id="服务器集群"><a href="#服务器集群" class="headerlink" title="服务器集群"></a>服务器集群</h2><p>单个服务器所支持的并发访问量有限，因此，为了提高服务器所支持的并发访问量，我们需要引入Nginx负载均衡器。</p><p>Nginx负载均衡器能够把客户端的请求按照负载均衡算法分发到具体业务服务器上，并且能够和Chatserver保持心跳机制，监测服务器的故障，避免将请求分发到故障的服务器上。同时，Nginx能够发现新添加的ChatServer服务器，可以自由地扩展服务器地数量。</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg"></p><p><strong>配置Nginx负载均衡模块：</strong></p><p><strong>1. 编译Nginx</strong></p><p>(1) 安装pcre、openssl、zlib库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo apt-get update</span><br><span class="hljs-comment"># sudo apt-get install libpcre3 libpcre3-dev libssl-dev zlib1g-dev</span><br></code></pre></td></tr></table></figure><p>(2) 在nginx目录下执行编译命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// --with-stream表示激活tcp模块，该命令需要在root用户下执行<br><span class="hljs-comment"># ./configure --with-stream</span><br><span class="hljs-comment"># make &amp;&amp; make install</span><br></code></pre></td></tr></table></figure><p>编译完成后，默认安装在&#x2F;usr&#x2F;local&#x2F;nginx目录下</p><p><strong>2. Nginx配置TCP负载均衡</strong></p><p>(1) 进入conf目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># cd /usr/local/nginx</span><br><span class="hljs-comment"># cd conf</span><br></code></pre></td></tr></table></figure><p>(2) 配置nginx.conf文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vim nginx.conf</span><br></code></pre></td></tr></table></figure><p>配置如下：</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240220164111777.png"></p><p>stream模块用于配置TCP和UDP的负载均衡器。在upstream中定义了两个后端服务器，每个后端服务器的权重为1，表示它们各自处理请求的比例是相同的。在server中配置了监听的端口号为8000，proxy pass为MyServer，表示将8000端口监听到的客户端请求转发给MyServer中的服务器。</p><p>(3) 配置完成后，重启nginx</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">nginx -s <span class="hljs-keyword">reload</span> <span class="hljs-comment"># 重新加载配置文件启动</span><br>nginx -s stop <span class="hljs-comment"># 停止nginx服务</span><br>nginx -s <span class="hljs-keyword">reload</span> 平滑重启<br></code></pre></td></tr></table></figure><h2 id="基于发布-订阅的redis消息队列"><a href="#基于发布-订阅的redis消息队列" class="headerlink" title="基于发布-订阅的redis消息队列"></a>基于发布-订阅的redis消息队列</h2><p>在ChatServer集群部署了多台服务器之后，登录在不同服务器上的用户需要进行跨服务器的通信。如果让每个ChatServer服务器之间直接建立TCP连接进行通信，这样的设计会占用系统大量的socket资源，各服务器之间的带宽压力会很大，并且各服务器之间的设计耦合度高，不利于扩展。</p><p>因此，可以引入中间件消息队列的方式，解耦各个服务器，提高服务器的响应能力，节省服务器的带宽资源。</p><p><strong>redis环境搭建：</strong></p><p><strong>1. 安装redis服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt-get install redis-server<br></code></pre></td></tr></table></figure><p><strong>2. 安装hiredis（redis对应的C++客户端编程）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 从GitHub上下载hiredis客户端，进行源码编译<br>$ git <span class="hljs-built_in">clone</span> https://github.com/redis/hiredis<br>$ <span class="hljs-built_in">cd</span> hiredis<br>$ make<br>$ sudo make install<br>$ sudo ldconfig /usr/local/lib<br></code></pre></td></tr></table></figure><p><strong>基于发布-订阅的redis消息队列的设计：</strong></p><p>当客户端登录成功后，<strong>服务端将该用户的id号subscribe到redis消息队列上</strong>，表示该服务器对这个id发生的事件感兴趣，服务器就能在接收到其他服务器往这个通道发来的消息；当用户下线时，需要从redis取消订阅。</p><p>在集群聊天服务器中，在执行私聊和群聊的业务时，服务端会检查私聊或群聊的对象是否登录在本地服务器上，如果没有，再检查数据库中该对象的信息是否在线。如果不在线，就储存到该用户的离线消息中；如果在线，<strong>就将消息向对方id所对应的通道publish消息，此时redis会通知对方用户登录的服务器订阅的通道接收到了消息</strong>，这样消息就成功进行了转发。</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240220201214068.png"></p><h2 id="增加数据库连接池"><a href="#增加数据库连接池" class="headerlink" title="增加数据库连接池"></a>增加数据库连接池</h2><p>数据库连接池的设计已经在<a href="http://zhcan.online/%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">手写数据库连接池</a>中介绍过，这里不再赘述。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="loginout后再login程序假死"><a href="#loginout后再login程序假死" class="headerlink" title="loginout后再login程序假死"></a>loginout后再login程序假死</h3><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240220205127157.png"></p><p><strong>问题定位：</strong></p><p><strong>1. <code>ps -u</code>查看进程号</strong></p><p><strong>2. <code>gdb attach 有问题的进程</code></strong></p><p><strong>3. <code>info threads</code>查看此时的线程数量</strong></p><p>可以看到，客户端程序的发送线程和接收线程都阻塞在recv操作上。</p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240220210728106.png"></p><p><strong>4. <code>bt</code>查看线程的调用堆栈</strong></p><p><img src="/./%E9%9B%86%E7%BE%A4%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20240220211130681.png"></p><p>因此，通过分析main.cpp:107和main.cpp:289的代码，我们可以看出：由于注销时并没有结束接收线程，当再次登录时，本该由主线程接收的登录响应消息，被接收线程给接收了，于是主线程阻塞在recv了，而子线程在处理完接收的消息后，也阻塞在recv了。</p><p><strong>问题解决：</strong></p><p>主线程不再接收消息，将接收消息的任务全都交给子线程（接收线程）。</p><ul><li>在client客户端完成socket连接后，就启动子线程</li><li>子线程接收到登录响应消息后，通过sem信号量通知主线程继续往下执行</li><li>使用基于CAS实现的atomic变量记录是否登录成功</li></ul><blockquote><p>注册的逻辑也相同</p></blockquote><blockquote><p>项目可以使用.&#x2F;autobuild.sh运行</p></blockquote><div class="note note-info">            <p>TIP：GitHub链接：<a href="https://github.com/ZHCANO/ChatServer">https://github.com/ZHCANO/ChatServer</a></p>          </div><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/shenmingxueIT/article/details/113199719">基于muduo网络库的集群聊天系统（C++实现）</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html">ORM 实例教程</a></li><li>施磊. 集群聊天服务器</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据库</tag>
      
      <tag>muduo</tag>
      
      <tag>Redis</tag>
      
      <tag>Nginx</tag>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL读写分离实战</title>
    <link href="/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AE%9E%E6%88%98/"/>
    <url>/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>搭建主从复制环境，可以参考上一篇<a href="http://zhcan.online/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">MySQL主从复制环境搭建</a></li></ul><h2 id="读写分离原理"><a href="#读写分离原理" class="headerlink" title="读写分离原理"></a>读写分离原理</h2><p><img src="/./MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AE%9E%E6%88%98/image-20240306203940130.png"></p><p>读写分离是指主服务器执行写操作，从服务器只执行读操作，通过将读操作和写操作分流到不同的服务器，可以减轻单台服务器的负载压力，提高其可用性。当主数据库发生故障或不可用时，读写分离可以自动将读操作切换到备用数据库上，保证系统的可用性，提高容灾能力。</p><p>在MySQL中，可以引入Mycat中间件来实现读写分离。</p><h2 id="读写分离配置"><a href="#读写分离配置" class="headerlink" title="读写分离配置"></a>读写分离配置</h2><p><strong>1. 安装Mycat</strong></p><ul><li><p>安装jdk1.7</p></li><li><p>解压Mycat安装包</p></li><li><p>建立Mycat软链接</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bat"># ln -s mycat文件的路径/bin/mycat /usr/bin/mycat<br># ll /usr/bin/mycat <br></code></pre></td></tr></table></figure></li></ul><p><strong>2. 配置Mycat</strong></p><p>&#x2F;mycat&#x2F;conf&#x2F;server.xml：配置登录Mycat的账号信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;schemas&quot;</span>&gt;</span>USERDB<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x2F;mycat&#x2F;conf&#x2F;schema.xml：配置逻辑库、数据源和读写分离等信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mycat</span>:schema <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;schema.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mycat:schema</span> <span class="hljs-attr">xmlns:mycat</span>=<span class="hljs-string">&quot;http://io.mycat/&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 逻辑数据库  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;USERDB&quot;</span> <span class="hljs-attr">checkSQLschema</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">sqlMaxLimit</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">dataNode</span>=<span class="hljs-string">&quot;dn1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 存储节点 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dataNode</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dn1&quot;</span> <span class="hljs-attr">dataHost</span>=<span class="hljs-string">&quot;node1&quot;</span> <span class="hljs-attr">database</span>=<span class="hljs-string">&quot;school&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数据库主机 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dataHost</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;node1&quot;</span> <span class="hljs-attr">maxCon</span>=<span class="hljs-string">&quot;1000&quot;</span> <span class="hljs-attr">minCon</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">balance</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">writeType</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">dbType</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">dbDriver</span>=<span class="hljs-string">&quot;native&quot;</span> <span class="hljs-attr">switchType</span>=<span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-attr">slaveThreshold</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">heartbeat</span>&gt;</span>select user()<span class="hljs-tag">&lt;/<span class="hljs-name">heartbeat</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- can have multi write hosts --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;192.168.18.131&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;192.168.18.131:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!-- can have multi read hosts --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">readHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;10.24.27.30&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;10.24.27.30:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">writeHost</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">writeHost</span> <span class="hljs-attr">host</span>=<span class="hljs-string">&quot;10.24.27.30&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;10.24.27.30:3306&quot;</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataHost</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mycat:schema</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><p><strong>balance：</strong>  </p><ul><li>“0”：不开启读写分离  </li><li>“1”：全部的readHost和stand by writeHost参与select语句的负载 </li><li>“2”：所有读操作随机在readHost和writeHost上分发 </li><li>“3”：所有读请求随机分发到writeHost对应的readHost上执行</li></ul><p><strong>writeType：</strong>“0”：所有写操作发送到配置的第一个writeHost，第一个挂掉切换到还生存的第二个writeHost </p><p><strong>switchType：</strong></p><ul><li>“-1”：不自动切换  </li><li>“1”：自动切换，发送心跳检测命令select user() </li><li>“2”：基于MySQL的主从同步状态决定是否进行切换，发送心跳检测命令：show slave status</li></ul><p><strong>3. 启动Mycat服务</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bat"># <span class="hljs-built_in">cd</span> mycat/bin<br># ./mycat <span class="hljs-built_in">start</span><br></code></pre></td></tr></table></figure><p><strong>4. 查看Mycat服务是否启动成功</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat"># sudo netstat -tnap |grep <span class="hljs-number">66</span> <br></code></pre></td></tr></table></figure><p>如果启动成功，会显示mycat的8066和9066端口号。如果启动不成功，可以查看Mycat的错误日志文件wapper.log。</p><p><strong>登录9066管理端口：</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># mysql -uroot -h 192.168.18.131 -P 9066 -p</span><br>&gt; <span class="hljs-keyword">show</span> <span class="hljs-comment">@@</span>help; <span class="hljs-comment">// 查看所有命令</span><br></code></pre></td></tr></table></figure><p><img src="/./MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AE%9E%E6%88%98/image-20240306214042498.png"></p><p><strong>登录8066数据端口：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"># mysql -uroot -h <span class="hljs-number">192.168</span>.<span class="hljs-number">18.131</span> -<span class="hljs-selector-tag">P</span> <span class="hljs-number">8066</span> -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>登录后，就可以对数据库表进行增删改查操作了。</p><h2 id="验证读写分离"><a href="#验证读写分离" class="headerlink" title="验证读写分离"></a>验证读写分离</h2><p>通过开启查询日志验证。查询日志会记录所有执行的SQL语句，通过登录Mycat的数据端口进行操作select或者insert操作，观察主服务器和从服务器的查询日志信息是否有变化，判断读写分离是否生效。</p><p>授予用户远程登录权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;192.168.18.131&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION;<br># GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;10.24.27.30&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION;<br># FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><p>查看查询日志是否开启：<code>show variables like &#39;general%&#39;;</code></p><p>开启查询日志：<code>set global general_log=on;</code></p><p>登录Mycat8066端口，执行一条插入&#x2F;查询操作，查看主库和从库的查询日志信息。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>施磊. 后台开发MySQL技术</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>读写分离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL主从复制环境搭建</title>
    <link href="/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>虚拟机：ubuntu 20.04</p><p>MySQL：虚拟机和本地各安装一台MySQL5.7</p><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p><img src="/./MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240306193422678.png"></p><p><strong>主从复制的流程：两个日志（binlog二进制日志和relay log日志）和三个线程（master的一个线程和slave的二个线程）</strong></p><ol><li>   主库的更新操作写入binlog二进制日志中，由binlog转储线程将二进制日志的内容发送到从服务器。</li><li>   slave从服务器执行start slave命令，创建一个IO线程和一个SQL线程。</li><li>   IO线程接收master的binary log并复制到中继日志中，SQL线程从中继日志中读取事件，并重放其中的事件更新slave从服务器中的数据，使其与master的数据一致。</li><li>   中继日志通常会位于OS缓存中，只要该线程与I&#x2F;O线程保持一致，中继日志的开销会很小。</li></ol><p><strong>主从复制采取的是半同步复制策略，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行</strong>，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。</p><h2 id="主从复制配置"><a href="#主从复制配置" class="headerlink" title="主从复制配置"></a>主从复制配置</h2><p>虚拟机Linux环境上的MySQL作为主服务器，本地windows环境的MySQL作为从服务器。</p><p><strong>查看主从服务器的IP地址</strong></p><p>在linux命令行输入<code>ifconfig</code>，记录IP地址，例如192.168.18.131</p><p>在windows命令行输入<code>ipconfig</code>，记录VMware Network Adapter VMnet8对应的IP地址，例如：192.168.18.1。</p><blockquote><p>虚拟机是从VMware Network Adapter VMnet8对应的IP地址接收对应的数据的</p></blockquote><p><strong>master配置：</strong></p><ol><li><p>开启二进制日志</p><p>打开<code>my.cnf</code>配置文件：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat"># sudo vim /etc/mysql/my.cnf<br></code></pre></td></tr></table></figure><p>添加配置项：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">server-id</span>=<span class="hljs-number">1</span> <span class="hljs-comment"># 全局唯一的server-id</span><br><span class="hljs-attr">expire_logs_days</span>=<span class="hljs-number">7</span> <span class="hljs-comment"># 过期时间</span><br><span class="hljs-attr">log-bin</span>=mysql-bin <span class="hljs-comment"># logbin日志名</span><br><span class="hljs-attr">bind-address</span>=<span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> <span class="hljs-comment">#允许来自任意地址的连接</span><br></code></pre></td></tr></table></figure><p>重启MySQL：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat"># sudo service mysql restart<br></code></pre></td></tr></table></figure></li><li><p>创建一个用于主从通信用的账号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user &#x27;mslave&#x27;@&#x27;192.168.18.1&#x27; identified by &#x27;12345@mysql&#x27;;<br>grant replication slave on *.* to &#x27;mslave&#x27;@&#x27;192.168.18.1&#x27; identified by &#x27;12345@mysql&#x27;;<br>flush privileges;<br></code></pre></td></tr></table></figure></li><li><p>查看mslave用户是否创建成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br>select user,host from user;<br></code></pre></td></tr></table></figure></li><li><p>获取binlog的日志文件名和position</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bat"># show master status;<br></code></pre></td></tr></table></figure><p><img src="/./MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240306195747112.png"></p></li></ol><p><strong>slave配置：</strong></p><ol><li><p>配置全局唯一的server-id</p><ul><li>在MySQL配置文件<code>my.ini</code>中修改server-id为2</li><li>重启mysql57服务</li></ul></li><li><p>使用master创建的账户读取binlog同步数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.18.131&#x27;,<br>MASTER_PORT=3306,<br>MASTER_USER=&#x27;mslave&#x27;,<br>MASTER_PASSWORD=&#x27;12345@mysql&#x27;,<br>MASTER_LOG_FILE=&#x27;mysql-bin.000002&#x27;,<br>MASTER_LOG_POS=482;<br></code></pre></td></tr></table></figure></li><li><p>开启主从复制<code>start slave</code></p></li><li><p>show slave status\G命令查看主从复制状态，确保显示的内容中没有error出现；</p></li><li><p>show processlist查看master和salve相关线程的运行状态</p></li></ol><p>此时，在主服务器创建一个新的数据库，从服务器就能实时同步查询到了。</p><blockquote><p>注意配置细节，在输入命令时，不要在密码后面误打空格造成连接失败。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>施磊. 后台开发MySQL技术</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>主从复制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL环境搭建</title>
    <link href="/MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><strong>(1) 安装mysql-server和mysql开发包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install mysql-server<br>sudo apt-get install libmysqlclient-dev<br></code></pre></td></tr></table></figure><p><strong>(2) 修改root用户的密码（初始用户名和密码是自动生成的，因此需要修改）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">cat</span> /etc/mysql/debian.cnf<br></code></pre></td></tr></table></figure><p><img src="/./MySQL%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20240209230033815.png"></p><p>使用上图的用户名和密码登录mysql：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u debian-sys-maint -p密码<br></code></pre></td></tr></table></figure><p>修改密码为<code>123456</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">update mysql.user <span class="hljs-built_in">set</span> authentication_string=password(<span class="hljs-string">&#x27;123456&#x27;</span>) <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span> and host=<span class="hljs-string">&#x27;localhost&#x27;</span>;<br>update mysql.user <span class="hljs-built_in">set</span> plugin=<span class="hljs-string">&quot;mysql_native_password&quot;</span>;<br>flush privileges;<br></code></pre></td></tr></table></figure><p><strong>(3) 重新登录mysql-server</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><p><strong>(4) 设置MySQL字符编码为utf-8</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看MySQL字符编码</span><br>show variables like <span class="hljs-string">&quot;char%&quot;</span>;<br><span class="hljs-comment"># 设置为utf8</span><br><span class="hljs-built_in">set</span> character_set_server=utf8;<br></code></pre></td></tr></table></figure><blockquote><p>修改表的字符编码：alter table user default character set utf8;</p><p>修改属性的字符编码：alter table user modify column name varchar(50) character set utf8;</p><p>配置文件可添加免密登录：skip-grant-tables</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vmware虚拟机代理设置</title>
    <link href="/Vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"/>
    <url>/Vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>虚拟机：Ubuntu 20.04</p><p>科学上网工具：v2rayN</p><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p><strong>1. 查看代理端口号</strong></p><p>打开v2rayN，查看代理端口，如下图</p><p><img src="/./Vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/image-20240113162334605.png"></p><p><code>http</code>端口为10809，<code>socks</code>端口为10808，路由选择全局代理。</p><p><strong>2. 设置允许来自局域网的连接</strong></p><p>v2rayN：点击设置-&gt;参数设置-&gt;打开允许来自局域网的连接</p><h2 id="虚拟机设置"><a href="#虚拟机设置" class="headerlink" title="虚拟机设置"></a>虚拟机设置</h2><p><strong>1. 选择NAT模式</strong></p><p>点击虚拟机-&gt;设置-&gt;网络设配器</p><p><img src="/./Vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/image-20240113162905473.png"></p><p><strong>2. 设置ubuntu网络代理</strong></p><p>在设置-&gt;网络中，选择手动设置网络代理，将本机IP（注意：填入无线局域网适配器 WLAN的IP）和代理端口填入</p><p><img src="/./Vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/image-20240113163228126.png"></p><p>打开ubuntu的浏览器，输入<code>www.google.com</code>，能够正常访问则说明设置成功。</p><p><img src="/./Vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/image-20240113163821956.png"></p><p><strong>3. 终端设置</strong></p><p>打开终端，输入<code>vim ~/.bashrc</code>，在文件末尾添加代理设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> http_proxy=http://IP:端口号<br><span class="hljs-built_in">export</span> https_proxy=http://IP:端口号<br></code></pre></td></tr></table></figure><p>保存后退出，输入<code>source ~/.bashrc</code>使设置生效。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zanez.top/2022/05/02/220502-Vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%9A%E8%BF%87%E4%B8%BB%E6%9C%BA%E4%BB%A3%E7%90%86%E4%B8%8A%E7%BD%91/">Vmware虚拟机通过主机代理上网</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>代理设置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode远程开发+免密登录</title>
    <link href="/VSCode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91+%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <url>/VSCode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91+%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="远程连接服务器"><a href="#远程连接服务器" class="headerlink" title="远程连接服务器"></a>远程连接服务器</h2><p><strong>1. 在Ubuntu上安装SSH Server</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install openssh-server<br>sudo /etc/init.d/ssh start<br></code></pre></td></tr></table></figure><p><strong>2. VSCode安装Remote-SSH</strong></p><p><img src="/./VSCode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91+%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/image-20240113191732773.png"></p><p><strong>3. 配置Remote-SSH</strong></p><p><img src="/./VSCode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91+%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/image-20240113191901944.png"></p><p>打开配置文件后添加主机IP和用户名：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host host_name<br>    HostName host_ip<br>    <span class="hljs-keyword">User</span> <span class="hljs-title">your_user_name</span><br></code></pre></td></tr></table></figure><p>保存后，左侧会出现连接的主机图标，右键即可连接。</p><p><img src="/./VSCode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91+%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/image-20240113192315624.png"></p><h2 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h2><p><strong>1. 本地windows生成公私钥</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 打开<span class="hljs-built_in">cmd</span>，输入命令，一直回车<br>ssh-keygen<br></code></pre></td></tr></table></figure><p><img src="/./VSCode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91+%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/image-20240113195005357.png"></p><p><strong>2. 将公钥推送到远端服务器</strong></p><p>远端服务器下新建.ssh目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/.ssh<br></code></pre></td></tr></table></figure><p>本地将公钥推送到远端服务器</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">scp 本地公钥路径 username@remote_server:远程.ssh路径<br></code></pre></td></tr></table></figure><p>用公钥文件来生成 authorized_keys：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> id_rsa.pub &gt;&gt; authorized_keys<br></code></pre></td></tr></table></figure><p><img src="/./VSCode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91+%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/image-20240113195541603.png"></p><p><strong>3. VScode Remote-SSH配置文件配置私钥路径</strong></p><p><img src="/./VSCode%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91+%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/image-20240113195650546.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode配置库路径</title>
    <link href="/VSCode%E9%85%8D%E7%BD%AE%E5%BA%93%E8%B7%AF%E5%BE%84/"/>
    <url>/VSCode%E9%85%8D%E7%BD%AE%E5%BA%93%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以muduo网络库的使用为例</p></blockquote><p>(1) 点击扩展-&gt;搜索cpp-&gt;安装C&#x2F;C++ Build Task</p><p><img src="/./VSCode%E9%85%8D%E7%BD%AE%E5%BA%93%E8%B7%AF%E5%BE%84/image-20231229200255560.png"></p><p>(2) 安装完成后，回到项目界面，点击ctrl+shift+B，在弹出的对话框中，点击任务这一行</p><p><img src="/./VSCode%E9%85%8D%E7%BD%AE%E5%BA%93%E8%B7%AF%E5%BE%84/image-20231229200416368.png"></p><p>(3) 选择g++，点击右侧的齿轮</p><p><img src="/./VSCode%E9%85%8D%E7%BD%AE%E5%BA%93%E8%B7%AF%E5%BE%84/image-20231229200612065.png"></p><p>(4) 在生成的<code>task.json</code>文件中添加项目所依赖的库</p><p><img src="/./VSCode%E9%85%8D%E7%BD%AE%E5%BA%93%E8%B7%AF%E5%BE%84/image-20231229200854289.png"></p><p>(5) 按快捷键ctrl+shift+B生成可执行文件</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写数据库连接池</title>
    <link href="/%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>在高并发情况下，如果每次用户访问数据库都需要创建和销毁数据库连接对象，这将导致大量的TCP三次握手、MySQL Server连接认证、MySQL Server关闭连接以及资源回收的操作，这些过程会带来巨大的性能开销。如果在一开始就创建好一些连接对象存放在连接池中，<strong>当用户需要时从连接池中取出，用完时归还，就可以起到资源重用</strong>，从而节省了频繁创建连接销毁连接所花费的时间，提升系统响应的速度。</p><h2 id="连接池功能"><a href="#连接池功能" class="headerlink" title="连接池功能"></a>连接池功能</h2><ul><li><p><strong>初始连接量（initSize）</strong></p><ul><li><p>连接池事先和MySQLServer创建initSize个连接</p></li><li><p>当应用发起MySQL访问时，直接从连接池中获取一个可用的连接，使用完成后归还连接池</p></li></ul></li><li><p><strong>最大连接量（maxSize）</strong></p><ul><li><p>当并发访问MySQL请求增多至超过初始连接量时，连接池会根据数量请求去创建更多的连接。</p></li><li><p>但是连接的数量上限是maxSize，因为连接占用socket资源，如果连接池占用过多的socket资源，那么服务器就不能接收太多的客户端请求了。（连接池和服务器部署在同一台主机上）</p></li></ul></li><li><p><strong>最大空闲时间（maxIdleTime）</strong></p><ul><li>如果新增加的连接在最大空闲时间内都没有被使用，那么这些连接就会被回收</li></ul></li><li><p><strong>连接超时时间（connectionTimeout）</strong></p><ul><li>如果在connectionTimeout内都没有空闲的连接可以使用，那么连接就会失败，无法访问数据库</li></ul></li></ul><h2 id="连接池设计"><a href="#连接池设计" class="headerlink" title="连接池设计"></a>连接池设计</h2><p><img src="/./%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/image-20231212194359092.png"></p><h2 id="关键技术点"><a href="#关键技术点" class="headerlink" title="关键技术点"></a>关键技术点</h2><ul><li>MySQL数据库编程</li><li>单例模式</li><li>C++11多线程编程、生产者-消费者线程模型</li><li>智能指针shared_ptr、lambda表达式</li></ul><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>使用vs2019编写项目代码，由于需要调用MySQL API来完成数据库的连接、查询和更新等操作，需要在vs2019中导入MySQL的头文件、库文件。</p><ol><li><p>VS2019选择X64，因为安装的MySQL是64位的</p><p><img src="/./%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/image-20231212195224271.png"></p></li><li><p>右键项目 - 属性 - C&#x2F;C++ - 常规 - 附加包含目录，填写mysql.h头文件的路径（例如：D:\developer_tools\MySQL\Files\MySQL Server 5.7\include）。注意：先在源文件下创建一个.cpp文件后，下图中C&#x2F;C++的选项才会出现。</p><p><img src="/./%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/image-20231212195956052.png"></p></li><li><p>右键项目 - 属性 - 链接器 - 常规 - 附加库目录，填写libmysql.lib的路径（D:\developer_tools\MySQL\Files\MySQL Server 5.7\lib）</p></li><li><p>右键项目 - 属性 - 链接器 - 输入 - 附加依赖项，填写libmysql.lib库的名字（libmysql.lib）（静态库）</p></li><li><p>把libmysql.dll动态链接库（Linux下后缀名是.so库）放在工程目录下（动态库）</p><p><img src="/./%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/image-20231212200957476.png"></p></li></ol><h2 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h2><p><strong>创建数据表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> databases pool;<br>use pool;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>(id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">PRIMARY</span> KEY <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    age <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    sex ENUM(<span class="hljs-string">&#x27;male&#x27;</span>,<span class="hljs-string">&#x27;female&#x27;</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><p><img src="/./%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/image-20231212201531855.png"></p><p><strong>MySQL C API</strong></p><p>需要包含头文件<code>#include &lt;mysql.h&gt;</code></p><ul><li><p>初始化MySQL连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 成功返回mysql指针，失败返回NULL</span><br>MYSQL *<span class="hljs-title function_">mysql_init</span><span class="hljs-params">(MYSQL *mysql)</span> ;<br></code></pre></td></tr></table></figure></li><li><p>连接MySQL服务器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 成功返回mysql指针，失败返回NULL</span><br>MYSQL * STDCALL <span class="hljs-title function_">mysql_real_connect</span><span class="hljs-params">(MYSQL *mysql, </span><br><span class="hljs-params">                                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *host,   <span class="hljs-comment">// mysql服务器的主机地址</span></span><br><span class="hljs-params">                                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *user,   <span class="hljs-comment">// 登录用户名</span></span><br><span class="hljs-params">                                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *passwd, <span class="hljs-comment">// 登录密码</span></span><br><span class="hljs-params">                                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *db,     <span class="hljs-comment">// 使用的数据库名称</span></span><br><span class="hljs-params">                                <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> port,  <span class="hljs-comment">// MySQL端口</span></span><br><span class="hljs-params">                                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *unix_socket,    <span class="hljs-comment">// 本地套接字, 不使用指定为NULL</span></span><br><span class="hljs-params">                                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> clientflag)</span>;  <span class="hljs-comment">// 连接标志，通常为0</span><br></code></pre></td></tr></table></figure></li><li><p>执行sql语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 执行一个sql语句, 增删查改的sql语句都可以</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mysql_query</span><span class="hljs-params">(MYSQL *mysql, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *query)</span>;<br>参数:<br>    - mysql: mysql_real_connect()的返回值<br>    - query: 一个可以执行的sql语句, 结尾的位置不需要加<span class="hljs-string">&#x27;;&#x27;</span><br>返回值: <br>    - 如果查询成功，返回<span class="hljs-number">0</span>。如果是查询, 结果集在mysql对象中<br>    - 如果出现错误，返回非<span class="hljs-number">0</span>值。<br></code></pre></td></tr></table></figure></li><li><p>获取结果集</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">MYSQL_RES *<span class="hljs-built_in">mysql_use_result</span>(_conn);<br></code></pre></td></tr></table></figure></li><li><p>关闭MySQL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mysql_close(&amp;mysql);<br></code></pre></td></tr></table></figure></li></ul><p><strong>使用C++封装MySQL C API</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONNECTION_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONNECTION_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mysql.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;public.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Connection</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 初始化数据库连接</span><br><span class="hljs-built_in">Connection</span>();<br><br><span class="hljs-comment">// 释放数据库连接</span><br>~<span class="hljs-built_in">Connection</span>();<br><br><span class="hljs-comment">// 连接数据库</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(string ip, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port, string user, string passward, string dbname)</span></span>;<br><br><span class="hljs-comment">// 更新操作insert/delete/update</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">update</span><span class="hljs-params">(string sql)</span></span>;<br><br><span class="hljs-comment">// 查询操作select</span><br><span class="hljs-function">MYSQL_RES* <span class="hljs-title">query</span><span class="hljs-params">(string sql)</span></span>;<br><span class="hljs-keyword">private</span>:<br>MYSQL* conn_; <span class="hljs-comment">// 表示和MySQL Server的一条连接</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 实现MySQL数据库的增删改查操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 初始化数据库连接</span><br>Connection::<span class="hljs-built_in">Connection</span>() &#123;<br>conn_ = <span class="hljs-built_in">mysql_init</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// 释放数据库连接</span><br>Connection::~<span class="hljs-built_in">Connection</span>() &#123;<br><span class="hljs-keyword">if</span> (conn_ != <span class="hljs-literal">nullptr</span>)<br><span class="hljs-built_in">mysql_close</span>(conn_);<br>&#125;<br><br><span class="hljs-comment">// 连接数据库</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Connection::connect</span><span class="hljs-params">(string ip, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port, string user, string password, string dbname)</span> </span>&#123;<br>MYSQL* p = <span class="hljs-built_in">mysql_real_connect</span>(conn_, ip.<span class="hljs-built_in">c_str</span>(), user.<span class="hljs-built_in">c_str</span>(),<br>password.<span class="hljs-built_in">c_str</span>(), dbname.<span class="hljs-built_in">c_str</span>(), port, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 输出连接失败原因</span><br>cerr &lt;&lt; <span class="hljs-built_in">mysql_error</span>(conn_) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> p != <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 更新操作insert/delete/update</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Connection::update</span><span class="hljs-params">(string sql)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">mysql_query</span>(conn_, sql.<span class="hljs-built_in">c_str</span>())) &#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Update Failed:&quot;</span> + sql);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 查询操作select</span><br><span class="hljs-function">MYSQL_RES* <span class="hljs-title">Connection::query</span><span class="hljs-params">(string sql)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">mysql_query</span>(conn_, sql.<span class="hljs-built_in">c_str</span>()))&#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;Query Failed:&quot;</span> + sql);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">mysql_use_result</span>(conn_);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试一下效果：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Connection conn;<br>string sql = <span class="hljs-string">&quot;insert into user(name,age,sex) values(&#x27;li&#x27;, 21, &#x27;female&#x27;)&quot;</span>;<br>conn.<span class="hljs-built_in">connect</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">13306</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;pool&quot;</span>);<br>conn.<span class="hljs-built_in">update</span>(sql);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，成功插入一条新数据：</p><p><img src="/./%E6%89%8B%E5%86%99%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/image-20231218193730375.png"></p><h2 id="功能模块实现"><a href="#功能模块实现" class="headerlink" title="功能模块实现"></a>功能模块实现</h2><h3 id="线程安全的懒汉式单例模式"><a href="#线程安全的懒汉式单例模式" class="headerlink" title="线程安全的懒汉式单例模式"></a>线程安全的懒汉式单例模式</h3><p>连接池只需要一个实例，所以ConnectionPool应该按照单例模式设计，即一个类不管创建多少对象，永远只能得到该类型的一个对象实例。单例模式又分为懒汉式单例模式和饿汉式单例模式。相比于懒汉式单例模式，饿汉式单例模式在没有需要获取实例对象前，实例对象就已经产生了，这样会浪费系统资源使启动时间过长。因此，在数据库连接池的设计中，我们使用线程安全的懒汉式单例模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONNECTIONPOOL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONNECTIONPOOL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 获取类的唯一实例对象的接口方法</span><br><span class="hljs-function"><span class="hljs-type">static</span> ConnectionPool* <span class="hljs-title">getConnectionPool</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 私有化构造函数</span><br><span class="hljs-built_in">ConnectionPool</span>(); <br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ConnectionPool.h&quot;</span></span><br><span class="hljs-comment">// 获取类的唯一实例对象的接口方法</span><br><span class="hljs-function">ConnectionPool* <span class="hljs-title">ConnectionPool::getConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">static</span> ConnectionPool pool; <span class="hljs-comment">// 编译器自动lock和unlock</span><br><span class="hljs-keyword">return</span> &amp;pool;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="从配置文件加载配置项"><a href="#从配置文件加载配置项" class="headerlink" title="从配置文件加载配置项"></a>从配置文件加载配置项</h3><ul><li>打开配置文件</li><li>判断文件是否存在</li><li>循环按行读取记录，按&#x3D;和\n分割提取key和value</li><li>给私有成员赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 从配置文件加载配置项</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ConnectionPool::loadConfigFile</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 以只读方式打开mysql.ini</span><br>ifstream ifs;<br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;mysql.ini&quot;</span>, ios::in);<br><br><span class="hljs-comment">// 判断配置文件是否存在</span><br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>()) &#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;mysql.ini file is not exist!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 循环按行读取记录，按=和\n分割提取key和value</span><br>string line;<br><span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ifs, line)) &#123;<br>string str = line;<br><span class="hljs-type">int</span> idx = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (idx == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 无效的配置项</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-type">int</span> endIdx = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;\n&#x27;</span>, idx);<br>string key = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, idx);<br>string value = str.<span class="hljs-built_in">substr</span>(idx + <span class="hljs-number">1</span>, endIdx - idx - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;ip&quot;</span>) &#123;<br>ip_ = value;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;port&quot;</span>) &#123;<br>port_ = <span class="hljs-built_in">stoi</span>(value);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;username&quot;</span>) &#123;<br>username_ = value;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;passward&quot;</span>) &#123;<br>passward_ = value;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;dbname&quot;</span>) &#123;<br>dbname_ = value;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;initSize&quot;</span>) &#123;<br>initSize_ = <span class="hljs-built_in">stoi</span>(value);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;maxSize&quot;</span>) &#123;<br>maxSize_ = <span class="hljs-built_in">stoi</span>(value);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;maxIdleTime&quot;</span>) &#123;<br>maxIdleTime_ = <span class="hljs-built_in">stoi</span>(value);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;connectionTimeout&quot;</span>) &#123;<br>connectionTimeout_ = <span class="hljs-built_in">stoi</span>(value);<br>&#125;<br>&#125;<br>ifs.<span class="hljs-built_in">close</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="连接池的构造"><a href="#连接池的构造" class="headerlink" title="连接池的构造"></a>连接池的构造</h3><ul><li>加载配置项</li><li>创建初始数量的连接</li><li>启动连接池的生产者线程</li><li>启动连接池定时清理线程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONNECTIONPOOL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CONNECTIONPOOL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 获取类的唯一实例对象的接口方法</span><br><span class="hljs-function"><span class="hljs-type">static</span> ConnectionPool* <span class="hljs-title">getConnectionPool</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 私有化构造函数</span><br><span class="hljs-built_in">ConnectionPool</span>(); <br><br><span class="hljs-comment">// 从配置文件加载配置项</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadConfigFile</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 生产者线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">produceConnectionTask</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 定时清理连接线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scannerConnectionTask</span><span class="hljs-params">()</span></span>;<br><br>string ip_; <span class="hljs-comment">// ip地址</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> port_; <span class="hljs-comment">// 端口号</span><br>string username_; <span class="hljs-comment">// 用户名</span><br>string passward_; <span class="hljs-comment">// 密码</span><br>string dbname_; <span class="hljs-comment">// 数据库名</span><br><span class="hljs-type">int</span> initSize_; <span class="hljs-comment">// 初始连接量</span><br><span class="hljs-type">int</span> maxSize_; <span class="hljs-comment">// 最大连接量</span><br><span class="hljs-type">int</span> maxIdleTime_; <span class="hljs-comment">// 最大空闲时间</span><br><span class="hljs-type">int</span> connectionTimeout_; <span class="hljs-comment">// 连接超时时间</span><br><br>queue&lt;Connection*&gt; connectionQue_; <span class="hljs-comment">// 存储 mysql 连接的队列</span><br>mutex queueMutex_; <span class="hljs-comment">// 维护连接队列线程安全的互斥锁</span><br>atomic_int connectionCnt_; <span class="hljs-comment">// 记录创建的连接的总数量</span><br>condition_variable cv; <span class="hljs-comment">// 设置条件变量，用于连接生产者线程和消费者线程的通信</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 连接池的构造</span><br>ConnectionPool::<span class="hljs-built_in">ConnectionPool</span>() &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">loadConfigFile</span>()) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 创建初始数量的连接</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; initSize_; i++) &#123;<br>Connection* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Connection</span>();<br>p-&gt;<span class="hljs-built_in">connect</span>(ip_, port_, username_, passward_, dbname_);<br>connectionQue_.<span class="hljs-built_in">push</span>(p);<br>connectionCnt_++;<br>&#125;<br><br><span class="hljs-comment">// 启动连接池的生产者线程</span><br><span class="hljs-function">thread <span class="hljs-title">produce</span><span class="hljs-params">(bind(&amp;ConnectionPool::produceConnectionTask, <span class="hljs-keyword">this</span>))</span></span>;<br>produce.<span class="hljs-built_in">detach</span>();<br><br><span class="hljs-comment">// 启动连接池定时清理连接线程</span><br><span class="hljs-function">thread <span class="hljs-title">scanner</span><span class="hljs-params">(bind(&amp;ConnectionPool::scannerConnectionTask, <span class="hljs-keyword">this</span>))</span></span>;<br>scanner.<span class="hljs-built_in">detach</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生产者线程"><a href="#生产者线程" class="headerlink" title="生产者线程"></a>生产者线程</h3><p><strong>作用：</strong>生产连接</p><ul><li>作为类的成员方法，可以很方便地访问类的成员变量<ul><li>由于线程函数是C接口的方法，因此传递函数时需要用绑定器将this指针绑定到生产者线程上</li></ul></li><li>加锁</li><li>连接池队列不空时，进入等待状态</li><li>连接池队列为空时，生产连接</li><li>通知消费者线程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 启动连接池的生产者线程</span><br><span class="hljs-function">thread <span class="hljs-title">produce</span><span class="hljs-params">(bind(&amp;ConnectionPool::produceConnectionTask, <span class="hljs-keyword">this</span>))</span></span>;<br>produce.<span class="hljs-built_in">detach</span>();<br><br><span class="hljs-comment">// 生产者线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConnectionPool::produceConnectionTask</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queueMutex_)</span></span>;<br><br><span class="hljs-comment">// 连接池队列不空，生产者线程进入等待状态</span><br><span class="hljs-keyword">while</span> (!connectionQue_.<span class="hljs-built_in">size</span>())<br>cv.<span class="hljs-built_in">wait</span>(lock);<br><br><span class="hljs-comment">// 连接数量没有达到上限，继续生产新的连接</span><br><span class="hljs-keyword">if</span> (connectionCnt_ &lt; maxSize_) &#123;<br>Connection* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Connection</span>();<br>p-&gt;<span class="hljs-built_in">connect</span>(ip_, port_, username_, passward_, dbname_);<br>connectionQue_.<span class="hljs-built_in">push</span>(p);<br>connectionCnt_++;<br>&#125;<br><br><span class="hljs-comment">// 通知消费者线程获取连接</span><br>cv.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费者线程"><a href="#消费者线程" class="headerlink" title="消费者线程"></a>消费者线程</h3><p><strong>作用：</strong>提供给外部的接口，从连接池中获取一个可用的空闲连接。返回一个智能指针（封装了连接），因为智能指针能够出作用域自动析构，可以重定义其删除器归还连接，避免让用户自己调用函数将连接归还，简化用户操作</p><ul><li>加锁</li><li>连接池队列为空时，进入等待状态，并判断是否连接超时</li><li>连接池队列不空时，消费连接</li><li>通知生产者线程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 消费者线程，提供给外部的接口，从连接池中获取一个可用的空闲连接</span><br><span class="hljs-function">shared_ptr&lt;Connection&gt; <span class="hljs-title">ConnectionPool::getConnection</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queueMutex_)</span></span>;<br><br><span class="hljs-comment">// 连接池队列为空，消费者线程进入等待状态</span><br><span class="hljs-keyword">while</span> (connectionQue_.<span class="hljs-built_in">empty</span>()) &#123;<br>cv_status status = cv.<span class="hljs-built_in">wait_for</span>(lock, chrono::<span class="hljs-built_in">milliseconds</span>(connectionTimeout_)); <span class="hljs-comment">// 线程池有连接唤醒/超时唤醒</span><br><span class="hljs-keyword">if</span> (status == cv_status::timeout &amp;&amp; connectionQue_.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 超时唤醒</span><br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;获取空闲连接超时...获取连接失败！&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* shared_ptr智能指针析构时，会把connection的资源delete，相当于调用connection的析构函数，connection就被close了</span><br><span class="hljs-comment">* 这里需要自定义shared_ptr的释放资源的方式，把connection直接归还到队列中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 从连接池队列取出一个连接</span><br><span class="hljs-function">shared_ptr&lt;Connection&gt; <span class="hljs-title">sp</span><span class="hljs-params">(connectionQue_.front(),</span></span><br><span class="hljs-params"><span class="hljs-function">[&amp;](Connection* pcon) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// 这是在服务器应用线程中调用的</span></span></span><br><span class="hljs-params"><span class="hljs-function">unique_lock&lt;mutex&gt; lock(queueMutex_);</span></span><br><span class="hljs-params"><span class="hljs-function">connectionQue_.push(pcon);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br>connectionQue_.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-comment">// 通知生产者线程生产</span><br><span class="hljs-keyword">if</span> (connectionQue_.<span class="hljs-built_in">empty</span>()) &#123;<br>cv.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br><span class="hljs-keyword">return</span> sp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定时清理连接线程"><a href="#定时清理连接线程" class="headerlink" title="定时清理连接线程"></a>定时清理连接线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定时清理连接线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConnectionPool::scannerConnectionTask</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-comment">// 通过sleep模拟定时效果</span><br>this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">seconds</span>(maxIdleTime_));<br><br><span class="hljs-comment">// 扫描整个队列，释放多余连接</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queueMutex_)</span></span>;<br><span class="hljs-keyword">while</span> (!connectionQue_.<span class="hljs-built_in">empty</span>()) &#123;<br>Connection* p = connectionQue_.<span class="hljs-built_in">front</span>();<br><span class="hljs-keyword">if</span> (connectionCnt_ &gt; initSize_ &amp;&amp; p-&gt;<span class="hljs-built_in">getAlivetime</span>() &gt;= maxIdleTime_ * <span class="hljs-number">1000</span>) &#123;<br>connectionQue_.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">delete</span> p;<br>connectionCnt_--;<br>&#125;<br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 队头连接没有超过最大空闲时间，其他连接肯定也没有</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在Linux下编译数据库连接池"><a href="#在Linux下编译数据库连接池" class="headerlink" title="在Linux下编译数据库连接池"></a>在Linux下编译数据库连接池</h2><p>将源文件和头文件放在一个文件夹下，如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── Connection<span class="hljs-selector-class">.cpp</span><br>├── Connection<span class="hljs-selector-class">.h</span><br>├── ConnectionPool<span class="hljs-selector-class">.cpp</span><br>├── ConnectionPool<span class="hljs-selector-class">.h</span><br>├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br>├── mysql<span class="hljs-selector-class">.ini</span><br>└── public.h<br></code></pre></td></tr></table></figure><p>在终端执行g++指令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 进入ConnectionPool目录</span><br>cd ConnectionPool<br><span class="hljs-comment"># g++ -o 可执行文件名 源文件1/2/3... </span><br><span class="hljs-comment"># 指定头文件的位置（-I）、库文件的目录（-L）、库名（-l）</span><br><span class="hljs-comment"># mysql头文件路径（-I/usr/include/mysql） mysql库文件路径（-L/usr/lib/x86_64-linux-gnu） 库名（-lmysqlclient）</span><br>g++ -o ConnectionPool Connection.cpp ConnectionPool.cpp main.cpp -I<span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/mysql -L/u</span>sr<span class="hljs-regexp">/lib/</span>x86_64-linux-gnu -lmysqlclient -lpthread<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ConnectionPool</span><br></code></pre></td></tr></table></figure><h2 id="Linux动态库"><a href="#Linux动态库" class="headerlink" title="Linux动态库"></a>Linux动态库</h2><p><strong>动态库的工作原理</strong></p><ul><li>静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中</li><li>动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中（会记录动态库的信息）</li><li><strong>动态库在程序运行时动态载入内存，当程序用到了动态库的哪个api，动态载入器会去寻找动态库文件放到内存里面</strong></li><li>可以通过ldd （list dynamic dependencies）命令检查动态库依赖关系</li></ul><p><strong>如何定位共享文件？</strong></p><ul><li>当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是<strong>还需要知道绝对路径</strong></li><li>系统的<strong>动态载入器来获取该绝对路径</strong></li><li>对于elf格式的可执行程序，是由<strong>ld-linux.so（动态载入器）</strong>来完成的，它先后搜索elf文件的 DT_RPATH段（无法修改） ——&gt; 环境变量LD_LIBRARY_PATH ——&gt; &#x2F;etc&#x2F;ld.so.cache文件列表 ——&gt; &#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。</li></ul><p><strong>数据库连接池动态库的生成</strong></p><p>生成.o的二进制目标文件，得到与位置无关的代码：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-comment"># -fPIC 选项表示生成位置无关</span><br>g<span class="hljs-operator">+</span><span class="hljs-operator">+</span> <span class="hljs-operator">-</span><span class="hljs-built_in">c</span> <span class="hljs-operator">-</span>fPIC Connection.cpp ConnectionPool.cpp<br></code></pre></td></tr></table></figure><p>生成动态库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">g++ -shared Connection<span class="hljs-selector-class">.o</span> ConnectionPool<span class="hljs-selector-class">.o</span> -o libconpool.so<br></code></pre></td></tr></table></figure><p>配置动态载入器加载路径：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 修改<span class="hljs-regexp">/etc/</span>ld.so.conf <br>sudo vim <span class="hljs-regexp">/etc/</span>ld.so.conf<br><span class="hljs-regexp">//</span> 添加路径<br><span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/workspace/</span>lib<br><span class="hljs-regexp">//</span> 使其生效<br>sudo ldconfig<br></code></pre></td></tr></table></figure><p>编译链接程序：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">g++ -o conn main.cpp -L<span class="hljs-regexp">/home/u</span>buntu<span class="hljs-regexp">/workspace/</span>lib -lconpool -pthread -I<span class="hljs-regexp">/usr/i</span>nclude<span class="hljs-regexp">/mysql -L/u</span>sr<span class="hljs-regexp">/lib/</span>x86_64-linux-gnu -lmysqlclient -lpthread<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./conn<br></code></pre></td></tr></table></figure><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><table><thead><tr><th align="center">数据量</th><th align="center">未使用连接池花费的时间</th><th align="center">使用连接池花费的时间</th></tr></thead><tbody><tr><td align="center">1000</td><td align="center">单线程：0.85s 四线程：0.73</td><td align="center">单线程：0.06 四线程：0.04</td></tr><tr><td align="center">5000</td><td align="center">单线程：4.13s 四线程：3.72</td><td align="center">单线程：0.23 四线程：0.16</td></tr><tr><td align="center">10000</td><td align="center">单线程：8.36s 四线程：7.56</td><td align="center">单线程：0.44 四线程：0.3</td></tr></tbody></table><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在windows下能够正常运行，但是在linux下连接服务器上数据库报错‘@’localhost’ (using password: YES) - Access denied for user ‘root。排查了密码和权限都没问题，最后发现是因为<strong>Linux和Unix使用的换行符是’\n’，而Windows使用的是’\r\n’</strong>。在windows下，std::getline() 函数默认会将\r\n视为换行符，因此它会读取整个行，但会忽略掉 \r。而在Linux中，std::getline 仅将\n视为换行符，因此在读取到换行符时，\r 会作为普通字符一起读入。</p><p>在加载配置文件函数中增加去除’&#x2F;r’的逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 去除空格和&#x27;\r&#x27;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; line.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span>(line[i]==<span class="hljs-string">&#x27; &#x27;</span> || line[i]==<span class="hljs-string">&#x27;\r&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>    str += line[i];<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>TIP：GitHub链接：<a href="https://github.com/ZHCANO/ConnectionPool">https://github.com/ZHCANO/ConnectionPool</a></p>          </div><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://juejin.cn/post/7141190286838857735">https://juejin.cn/post/7141190286838857735</a></p></li><li><p><a href="https://open.alipay.com/portal/forum/post/126001176">https://open.alipay.com/portal/forum/post/126001176</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Linux</tag>
      
      <tag>数据库</tag>
      
      <tag>连接池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeanCloud+Hexo开启评论和文章阅读量</title>
    <link href="/LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/"/>
    <url>/LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前面我们已经完成了<a href="http://zhcan.online/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">hexo博客的搭建并成功部署到服务器和GitHub Pages</a>，但还没有实现开启评论和文章访问量的功能。因为我开始搭建博客时，按照网上的教程都没有成功实现，于是这一部分功能就被我推迟了，下面分享我的踩坑经历，操作步骤可能存在冗余，但是因为时间有限，就没有逐一验证哪些是不必要的操作。</p></blockquote><h2 id="1-注册LeanCloud"><a href="#1-注册LeanCloud" class="headerlink" title="1. 注册LeanCloud"></a>1. 注册LeanCloud</h2><p>(1) 前往LeanCloud官网完成注册：<a href="https://www.leancloud.cn/">https://www.leancloud.cn/</a></p><p>(2) 点击创建应用，填写应用名称，完成创建</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228183108135.png"></p><p>(3) 点击创建好的应用-&gt;设置-&gt;应用凭证</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228183337341.png"></p><p>此处的AppID、AppKey和REST API在后面会用到。</p><h2 id="2-开启评论功能"><a href="#2-开启评论功能" class="headerlink" title="2. 开启评论功能"></a>2. 开启评论功能</h2><p>(1) 打开主题配置文件_config.yml，搜索<code>Comment</code>，修改<code>enable</code>和<code>type</code>。</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228183740993.png"></p><p>(2) 搜索<code>valine</code>，将前面提到的<code>AppID</code>和<code>AppKey</code>粘贴到这里</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228183857864.png"></p><div class="note note-success">            <p>TIP：这里参考【<a href="https://www.jianshu.com/p/0b4cf14663f7">hexo添加评论功能</a>】增加了多个版本的appId和appKey。</p>          </div><p>(3) 如果有域名，可以在安全中心添加域名。</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228184305009.png"></p><p>重新启动hexo，如果文章底部出现了评论区，就说明部署成功了。</p><p>(4) 点击数据存储-&gt;结构化数据库-&gt;Comment，可以管理评论区的评论。</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228184523762.png"></p><div class="note note-success">            <p>TIP：我关闭了评论功能，因为开启评论公安备案似乎要选交互式。</p>          </div><h2 id="3-开启网页-文章阅读量、访问量统计"><a href="#3-开启网页-文章阅读量、访问量统计" class="headerlink" title="3. 开启网页&#x2F;文章阅读量、访问量统计"></a>3. 开启网页&#x2F;文章阅读量、访问量统计</h2><p>(1) 网页访问统计</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228185018320.png"></p><p>(2) 点击数据存储-&gt;结构化数据库-&gt;创建Class，填写Class名称为Counter（必须为Counter），选择无限制，创建。</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228190605438.png"></p><p>后续网站的访问次数都会自动保存在Counter中。</p><p>(3) 填写<code>AppID</code>、<code>AppKey</code>和<code>server_url</code></p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228185224919.png" alt="i"></p><p>(3) PV与UV统计</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228185322644.png"></p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228185524697.png"></p><div class="note note-success">            <p>TIP：<code>{}</code>中间不要有空格。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">pv_format:</span> <span class="hljs-string">&quot;总访问量 &#123;&#125; 次&quot;</span><br><span class="hljs-symbol">uv_format:</span> <span class="hljs-string">&quot;总访客数 &#123;&#125; 人</span><br></code></pre></td></tr></table></figure>          </div><p>重新启动hexo，如果出现了在页头和页尾出现了访问次数，那么说明设置成功了，例如：</p><p><img src="/./LeanCloud+Hexo%E5%BC%80%E5%90%AF%E8%AF%84%E8%AE%BA%E5%92%8C%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/image-20231228185820048.png"></p><div class="note note-success">            <p>TIP：本机访问网页也会使访问次数加1，可以将<code>LeanCloud</code>的<code>ignore_local</code>设置为<code>true</code>避免本地访问导致次数增加，上图就是开启后的效果。如果没有开启这个功能，本地访问这个页面一次，计数值就会加1。</p>          </div><p>到这里，就完成了评论功能和浏览量功能的设置，如果浏览量还是无法正常显示，可以在主题配置文件_config.yml搜索LeanCloud查找是否遗漏的设置。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/0b4cf14663f7">hexo添加评论功能</a></li><li><a href="https://blog.csdn.net/qq_34243930/article/details/109046865">用Github Pages+Hexo搭建博客之(八)Hexo博客Next主题添加统计文章阅读量（访问量&#x2F;浏览量&#x2F;阅读次数）功能</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>LeanCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+GitHub Pages+服务器搭建个人网站</title>
    <link href="/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="1-1-GitHub账号"><a href="#1-1-GitHub账号" class="headerlink" title="1.1 GitHub账号"></a>1.1 GitHub账号</h3><ul><li>注册GitHub账号</li><li>GitHub官网：<a href="https://github.com/">https://github.com/</a></li></ul><h3 id="1-2-安装Git"><a href="#1-2-安装Git" class="headerlink" title="1.2 安装Git"></a>1.2 安装Git</h3><ul><li><p>下载地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p></li><li><p>安装方式：双击安装包，一直点next</p></li></ul><p>安装完成后，鼠标右键任意位置，在右键菜单中选择<code>Git Bash Here</code>，弹出Git命令行，在命令行配置Git用户名和邮箱地址，以便区分不同提交者的身份。（<strong>注意：这里设置用户签名和将来登录GitHub的账号没有任何关系</strong>）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 配置Git用户名和邮箱地址</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;用户名&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;邮箱&quot;</span><br><span class="hljs-comment">// 查看配置</span><br>cat ~/.gitconfig<br></code></pre></td></tr></table></figure><h3 id="1-3-安装Node-JS"><a href="#1-3-安装Node-JS" class="headerlink" title="1.3 安装Node JS"></a>1.3 安装Node JS</h3><ul><li><p>下载地址：<a href="https://nodejs.cn/download/">https://nodejs.cn/download/</a></p></li><li><p>安装方式：双击安装包，一直点next</p></li><li><p>安装完成后，打开cmd，输入<code>node -v</code>和<code>npm -v</code>，若显示对应版本号，则说明安装成功。</p></li></ul><p><strong>(1) 修改全局模块路径和缓存路径</strong></p><p>输入<code>npm -root -g</code>查看默认路径，默认路径在<code>C:\Users\用户名\AppData\Roaming\npm\node_modules</code>。</p><div class="note note-success">            <p>TIP：此文件夹默认是隐藏的，需要设置显示隐藏的文件夹才能查看</p>          </div><p><strong>(2) 在nodejs安装目录中新建node_cache和node_global文件夹</strong></p><p><img src="/./%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20231228115317381.png"></p><p><strong>(3) 修改全局模块路径和缓存路径为新建的这两个文件夹</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;创建的node_global文件夹所在路径&quot;</span><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;创建的node_cache文件夹所在路径&quot;</span><br></code></pre></td></tr></table></figure><p><strong>(4) 修改完成后，配置环境变量，右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</strong></p><ol><li>在用户环境变量Path中添加node_global的路径</li><li>在系统变量中，新建变量名NODE_PATH，变量值为node_global的node_modules文件夹路径。</li></ol><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装Hexo</h2><p><strong>(1) 运行Git Bash并切换淘宝镜像（提高下载速度）</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 全局切换命令</span><br>npm config set registry http:<span class="hljs-comment">//registry.npm.taobao.org/</span><br><span class="hljs-comment">// 查看版本命令</span><br>npm get registry<br><span class="hljs-comment">// 切回官方镜像</span><br>npm config set registry http:<span class="hljs-comment">//www.npmjs.org</span><br></code></pre></td></tr></table></figure><p><strong>(2) 安装Hexo</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><p><strong>npm install 报错：</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ npm install hexo-<span class="hljs-keyword">cli</span> -<span class="hljs-keyword">g</span><br>npm <span class="hljs-keyword">ERR</span>! code EPERM<br>npm <span class="hljs-keyword">ERR</span>! syscall <span class="hljs-keyword">mkdir</span><br>npm <span class="hljs-keyword">ERR</span>! path <span class="hljs-keyword">D</span>:\DevelopTools\nodejs\node_global\node_modules<br>npm <span class="hljs-keyword">ERR</span>! errno -4048<br>npm <span class="hljs-keyword">ERR</span>! <span class="hljs-keyword">Error</span>: EPERM: operation not permitted, <span class="hljs-keyword">mkdir</span> &#x27;<span class="hljs-keyword">D</span>:\DevelopTools\nodejs\node_global\node_modules&#x27;<br></code></pre></td></tr></table></figure><p><strong>解决方法：找到缓存位置，设置nodejs文件夹权限为完全控制</strong></p><p><img src="/./%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20231228115706989.png"></p><p><strong>(3) 创建hexo-blog项目</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">hexo init hexo-<span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>cd hexo-<span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p><strong>(4) 本地启动</strong></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo g<br>hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>此时，在浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以访问到hexo的默认页面了</p><h2 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h2><p><strong>1. 按照官方文档安装Fluid主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></strong></p><p><strong>2. 按照官方配置指南完成自己想要的配置：<a href="https://hexo.fluid-dev.com/docs/guide/">配置指南</a></strong></p><h2 id="4-创建文章"><a href="#4-创建文章" class="headerlink" title="4. 创建文章"></a>4. 创建文章</h2><p>修改hexo-blog目录下_config.yml，在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>1. 创建各种页</strong></p><p>(1) 关于页：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about <span class="hljs-meta"># 在hexo-blog/source/about目录下生成index.md</span><br></code></pre></td></tr></table></figure><p>编辑<code>index.md</code>，添加<code>layout: about</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2023-11-08 11:51:44</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>(2) 分类页：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about categories<br></code></pre></td></tr></table></figure><p>添加<code>type: &quot;categories&quot;</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">title</span>: categories<br><span class="hljs-attribute">date</span>: <span class="hljs-number">2023</span>-<span class="hljs-number">12</span>-<span class="hljs-number">23</span> <span class="hljs-number">18</span>:<span class="hljs-number">26</span>:<span class="hljs-number">53</span><br><span class="hljs-attribute">type</span>: <span class="hljs-string">&quot;categories&quot;</span><br></code></pre></td></tr></table></figure><p>(3) 标签页：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about tags<br></code></pre></td></tr></table></figure><p>添加<code>type: &quot;tags&quot;</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">title</span>: tags<br><span class="hljs-attribute">date</span>: <span class="hljs-number">2023</span>-<span class="hljs-number">12</span>-<span class="hljs-number">23</span> <span class="hljs-number">18</span>:<span class="hljs-number">32</span>:<span class="hljs-number">39</span><br><span class="hljs-attribute">type</span>: <span class="hljs-string">&quot;tags&quot;</span><br></code></pre></td></tr></table></figure><p><strong>2. 创建文章</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> 测试文章 <span class="hljs-meta">#在hexo-blog/source/_posts目录下生成测试文章.md和同名文件夹</span><br></code></pre></td></tr></table></figure><p>打开测试文章.md，添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">测试文章</span><br><span class="hljs-attr">banner_img:</span> <span class="hljs-string">/img/post.png</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2023-11-08 12:01:42</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">C++</span><br><span class="hljs-meta">---</span><br><span class="hljs-type">![](./</span><span class="hljs-string">测试文章/test.png)</span><br><span class="hljs-string">这是一篇测试文章</span><br></code></pre></td></tr></table></figure><div class="note note-success">            <p>TIP：banner_img: &#x2F;img&#x2F;post.png是自定义的文章顶部背景图片的路径，categories:是类别，tags:是标签。</p>          </div><p><strong>配置在Hexo博客和Markdown编辑器中正确显示图片：</strong></p><p>首先，根据Hexo官方文档，在_config.yaml将post_asset_folder选项设为true 。然后，安装插件hexo-image-link，安装命令为：</p><pre><code class="hljs">npm install hexo-image-link --save</code></pre><p>如果安装了 hexo-asset-img 插件，需要将其卸载：</p><pre><code class="hljs">$ npm uninstall --save hexo-asset-img</code></pre><p>配置向Typora文档粘贴图片时自动保存图片到同名文件夹：</p><p><img src="/./%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20231224153239095.png"></p><div class="note note-success">            <p>TIP</p><p>粘贴后不要缩放图片，会导致路径不可用，必须保证图片的路径格式为<code>![]()</code></p><p>如果希望图片居中显示，可以卸载 hexo-image-link</p>          </div><h2 id="5-将hexo推送到GitHub-Pages"><a href="#5-将hexo推送到GitHub-Pages" class="headerlink" title="5.  将hexo推送到GitHub Pages"></a>5.  将hexo推送到GitHub Pages</h2><p><strong>1. 在GitHub上创建仓库</strong></p><p>可参考<a href="https://princehao.cn/posts/blog001/">这篇博客的配置GitHubPages部分</a>，注意仓库名必须为<code>你的用户名.github.io</code></p><p><strong>2. Github配置ssh key</strong></p><p>原理：本地生成一个公私钥对，将公钥放到远程主机，当本地主机需要登录远程主机时，远程主机用公钥对对一个随机字符串加密，并将结果发回本地主机。本地主机用私钥解密，将内容发回到远程主机，远程主机对比传回的字符串与生成的字符串，如果相同则认证成功。（公钥可以理解为锁，私钥是钥匙）</p><p>(1) 打开git bash，生成ssh key</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-keygen -t rsa   <span class="hljs-comment">// 生成公钥</span><br>cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub <span class="hljs-comment">// 复制公钥</span><br></code></pre></td></tr></table></figure><p>(2) Github账号上添加公钥</p><p>点击settings-&gt;SSH and GPG kyes-&gt;new ssh key，将刚刚生成的公钥粘贴进去</p><p>(3) 验证设置是否成功</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p><img src="/./%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20231225155759193.png"></p><p><strong>3. 将本地博客部署到GitHub Pages</strong></p><p>打开hexo-blog&#x2F;_config.yml，在deployment配置项下设置：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">    type:</span> git<br><span class="hljs-symbol">    repo:</span> 此处复制仓库的SSH地址，如下图<br><span class="hljs-symbol">    branch:</span> master<br></code></pre></td></tr></table></figure><p><img src="/./%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20231225201809703.png"></p><p>git bash输入<code>hexo d</code></p><p>浏览器访问<code>https://zhcano.github.io/</code>，显示页面则部署成功。</p><h2 id="6-配置域名"><a href="#6-配置域名" class="headerlink" title="6. 配置域名"></a>6. 配置域名</h2><p><strong>1. 购买域名和服务器</strong></p><p>(1) 在腾讯云&#x2F;阿里云（下面以腾讯云为例）购买一个轻量级服务器，最便宜的大概200+</p><p>(2) 在腾讯云购买一个域名，最便宜的大概10元左右</p><p><strong>2. 国内网站需要ICP域名备案</strong></p><p>参考链接：<a href="https://blog.csdn.net/qq_62982856/article/details/133307488">域名备案流程（个人备案，腾讯云 &#x2F; 阿里云）</a></p><p>大概流程是：提交备案材料-&gt;腾讯云审核-&gt;管局审核-&gt;公安备案</p><div class="note note-success">            <p>TIP：必须先备案再域名解析，否则腾讯云会打电话通知删除域名解析。</p>          </div><p><strong>3. 域名解析</strong></p><p>参考链接：<a href="https://cloud.tencent.com/document/product/302/3446">云解析 DNS 快速添加域名解析-快速入门-文档中心-腾讯云 (tencent.com)</a></p><h2 id="7-将hexo推送到云服务器"><a href="#7-将hexo推送到云服务器" class="headerlink" title="7. 将hexo推送到云服务器"></a>7. 将hexo推送到云服务器</h2><p><strong>1. xshell远程连接服务器</strong></p><p><strong>2. 安装git和nginx</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">apt-get install nginx<br>apt-get install git<br></code></pre></td></tr></table></figure><p><strong>3. 添加git用户</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">adduser git   <span class="hljs-comment">#添加git用户</span><br><span class="hljs-built_in">chmod</span> 740 /etc/sudoers   <span class="hljs-comment">#改变sudoers文件的权限为文件所有者可写</span><br>vim /etc/sudoers   <br></code></pre></td></tr></table></figure><p>找到root ALL&#x3D;(ALL) ALL，在它下方加入一行</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>) <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 400 /etc/sudoers   <span class="hljs-comment">#将其权限修改为文件所有者可读</span><br>sudo passwd git  <span class="hljs-comment">#设置git用户的密码</span><br></code></pre></td></tr></table></figure><p><strong>4. 给git用户添加ssh密钥</strong></p><p>使用<code>五、将本地博客部署到GitHub Pages</code>中生成的密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">su git <span class="hljs-comment">#切换到git用户</span><br><span class="hljs-built_in">mkdir</span> ~/.ssh  <span class="hljs-comment">#创建.ssh文件夹</span><br><span class="hljs-built_in">touch</span> ~/.ssh/authorized_keys  <span class="hljs-comment">#创建authorized_keys文件</span><br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys  <span class="hljs-comment">#为authorized_keys文件赋予文件所有者可读可写的权限</span><br><span class="hljs-built_in">chmod</span> 700 ~/.ssh  <span class="hljs-comment">#为.ssh文件夹赋予文件夹所有者可读可写可执行的权限</span><br>vim ~/.ssh/authorized_keys <span class="hljs-comment">#将ssh密钥粘贴进去</span><br></code></pre></td></tr></table></figure><p>测试在Git Bash中使用<code>ssh git@你的服务器地址</code>连接服务器是否成功。</p><p><strong>5. 创建git仓库并使用git-hooks实现自动部署</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /var/repo <span class="hljs-comment"># 新建git仓库位置</span><br>sudo <span class="hljs-built_in">mkdir</span> /var/hexo <span class="hljs-comment"># 新建静态资源的目录</span><br><span class="hljs-built_in">cd</span> /var/repo<br>sudo git init --bare blog.git <span class="hljs-comment"># 创建一个名叫blog的仓库</span><br>sudo vim /var/repo/blog.git/hooks/post-update <span class="hljs-comment"># 配置hooks实现自动部署</span><br></code></pre></td></tr></table></figure><p>添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>git --work-tree=/var/hexo --git-dir=/var/repo/blog.git checkout -<br></code></pre></td></tr></table></figure><p>增加权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> blog.git/hooks/<br>sudo <span class="hljs-built_in">chown</span> -R git:git /var/repo/      <br>sudo <span class="hljs-built_in">chown</span> -R git:git /var/hexo         <br>sudo <span class="hljs-built_in">chmod</span> +x post-update<br></code></pre></td></tr></table></figure><p><strong>6. 配置nginx</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">// 查找 nginx 配置文件的路径<br>sudo nginx -t<br>输出：nginx: the configuration <span class="hljs-keyword">file</span> /etc/nginx/nginx.<span class="hljs-keyword">conf</span> <span class="hljs-keyword">syntax</span> <span class="hljs-keyword">is</span> ok<br><span class="hljs-keyword">cd</span> /etc/nginx/<br><span class="hljs-built_in">mkdir</span> vhost<br><span class="hljs-keyword">cd</span> vhost<br>sudo <span class="hljs-keyword">vim</span> blog.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">server</span>&#123;<br>        <span class="hljs-keyword">listen</span> <span class="hljs-number">80</span> default_server;<br>        <span class="hljs-keyword">listen</span> [::]:<span class="hljs-number">80</span> default_server;<br>        root /var/hexo;<br>        server_name 域名; <br>        <span class="hljs-keyword">location</span> /&#123;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">vim</span> /etc/nginx/nginx.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></table></figure><p>在http模块下添加：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/vhost/</span>*.conf;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>TIP：这里设置的80端口和nginx默认页面的80端口冲突，可以将nginx默认页面的80端口注释掉。</p>          </div><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">cd /etc/nginx/sites-available<br>sudo vim <span class="hljs-keyword">default</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">server</span> &#123;<br>        <span class="hljs-meta"># listen 80 default_server;</span><br>        <span class="hljs-meta"># listen [::]:80 default_server;</span><br>        ...<br></code></pre></td></tr></table></figure><p>重新加载Nginx：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo systemctl reload nginx</span><br></code></pre></td></tr></table></figure><p><strong>7. 给git用户设置权限</strong></p><p>避免git用户通过ssh git@ip登录，也不能通过su git切换到git用户。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo vim <span class="hljs-regexp">/etc/</span>passwd<br><span class="hljs-regexp">//</span> 修改最后一行<br><span class="hljs-regexp">//</span> 将<span class="hljs-regexp">/bin/</span>bash修改为<span class="hljs-regexp">/usr/</span>bin/git-shell<br></code></pre></td></tr></table></figure><p><strong>8. 本地hexo设置</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-comment">#vim config.yml</span><br><span class="hljs-attribute">deploy</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">type: git</span><br>    <span class="hljs-attribute">repo</span><span class="hljs-punctuation">:</span> <span class="hljs-string">github仓库的SSH地址</span><br>    <span class="hljs-attribute">branch</span><span class="hljs-punctuation">:</span> <span class="hljs-string">main</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">type: git</span><br>    <span class="hljs-attribute">repo</span><span class="hljs-punctuation">:</span> <span class="hljs-string">git@你的ip:/var/repo/blog.git</span><br>    <span class="hljs-attribute">branch</span><span class="hljs-punctuation">:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>hexo d 将本地博客推送至服务器和github，此时输入域名和输入github.io地址都能访问到自己博客了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程</a></li><li><a href="https://arcsin2.cloud/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">Hexo 博客无法显示图片解决方法</a></li><li><a href="https://princehao.cn/posts/blog001/">Hexo+Fluid搭建个人博客网站</a></li><li><a href="https://zhuanlan.zhihu.com/p/453999928">结合 nginx + git 将 hexo 推送到云服务器</a></li><li><a href="https://zhuanlan.zhihu.com/p/83095214">通过Git将Hexo博客部署到服务器</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git和Github的使用</title>
    <link href="/Git%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <url>/Git%E4%B8%89%E5%89%91%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h2><h3 id="1-Git安装"><a href="#1-Git安装" class="headerlink" title="1. Git安装"></a>1. Git安装</h3><ul><li><a href="https://git-scm.com/">https://git-scm.com/</a></li></ul><h3 id="2-Git-的工作机制"><a href="#2-Git-的工作机制" class="headerlink" title="2. Git 的工作机制"></a>2. Git 的工作机制</h3><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225185210032.png"></p><h3 id="3-Git的常用命令"><a href="#3-Git的常用命令" class="headerlink" title="3. Git的常用命令"></a>3. Git的常用命令</h3><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225185311115.png"></p><p><strong>查看签名：</strong>cat ~&#x2F;.gitconfig</p><p><strong>初始化本地库：</strong>git init</p><p><strong>查看本地库状态：</strong>git status</p><p><strong>新建文件（未追踪的文件，在工作区）：</strong></p><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225190122095.png"></p><p><strong>添加暂存区：</strong>git add 文件名</p><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225190256293.png"></p><p><strong>提交本地库：</strong>git commit -m “日志信息” 文件名</p><p><strong>修改文件：</strong></p><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225190728610.png"></p><p><strong>查看版本号：</strong></p><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225190947555.png"></p><p><strong>版本穿梭：</strong>git reset –hard 版本号</p><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225191214074.png"></p><h3 id="4-Git分支操作"><a href="#4-Git分支操作" class="headerlink" title="4. Git分支操作"></a><strong>4. Git分支操作</strong></h3><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225191321323.png"></p><div class="note note-success">            <p>TIP: 创建的新的分支，会将主分支master的内容复制一份，之后切换到新的分支做修改</p>          </div><p><strong>合并分支：</strong></p><p>产生冲突的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git 无法替我们决定使用哪一个。必须人为决定新代码内容。</p><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225192752113.png"></p><p><strong>解决冲突：</strong></p><ul><li><p>编辑有冲突的文件，删除特殊符号，决定要使用的内容</p></li><li><p>特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 合并过来的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</p></li></ul><ul><li>添加到暂存区，重新提交（注意：此时使用 git commit 命令时不能带文件名）</li></ul><h2 id="二、GitHub"><a href="#二、GitHub" class="headerlink" title="二、GitHub"></a>二、GitHub</h2><h3 id="1-创建远程仓库"><a href="#1-创建远程仓库" class="headerlink" title="1. 创建远程仓库"></a>1. 创建远程仓库</h3><p>(1) 点击GitHub首页右上角的“+”按钮，在弹出窗口选择“New respository”</p><p>(2) 输入仓库名，点击创建</p><h3 id="2-远程仓库操作"><a href="#2-远程仓库操作" class="headerlink" title="2. 远程仓库操作"></a>2. 远程仓库操作</h3><p><img src="/./Git%E4%B8%89%E5%89%91%E5%AE%A2/image-20231225193734395.png"></p><h3 id="3-GitHub免密登录"><a href="#3-GitHub免密登录" class="headerlink" title="3. GitHub免密登录"></a>3. GitHub免密登录</h3><p><strong>1. 在GitHub上创建仓库</strong></p><p>可参考<a href="https://princehao.cn/posts/blog001/">这篇博客的配置GitHubPages部分</a></p><p><strong>2. Github配置ssh key</strong></p><p>原理：本地生成一个公私钥对，将公钥放到远程主机，当本地主机需要登录远程主机时，远程主机用公钥对对一个随机字符串加密，并将结果发回本地主机。本地主机用私钥解密，将内容发回到远程主机，远程主机对比传回的字符串与生成的字符串，如果相同则认证成功。（公钥可以理解为锁，私钥是钥匙）</p><p>(1) 打开git bash，生成ssh key</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-keygen -t rsa   <span class="hljs-comment">// 生成公钥</span><br>cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub <span class="hljs-comment">// 复制公钥</span><br></code></pre></td></tr></table></figure><p>(2) Github账号上添加公钥</p><p>点击settings-&gt;SSH and GPG kyes-&gt;new ssh key，将刚刚生成的公钥粘贴进去</p><p>(3) 验证设置是否成功</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>尚硅谷技术课程系列之 Git</li></ul>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
